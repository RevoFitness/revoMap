{"id":"wXs0","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../Collection.js","loc":{"line":17,"column":23,"index":647},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\Collection.js"},{"name":"../render/EventType.js","loc":{"line":18,"column":22,"index":689},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\EventType.js"},{"name":"../Feature.js","loc":{"line":19,"column":20,"index":735},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\Feature.js"},{"name":"../style/Fill.js","loc":{"line":20,"column":17,"index":769},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Fill.js"},{"name":"../geom/GeometryLayout.js","loc":{"line":21,"column":27,"index":816},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\GeometryLayout.js"},{"name":"../geom/LineString.js","loc":{"line":22,"column":23,"index":868},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\LineString.js"},{"name":"../geom/Point.js","loc":{"line":23,"column":18,"index":911},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\Point.js"},{"name":"../style/Stroke.js","loc":{"line":24,"column":19,"index":950},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Stroke.js"},{"name":"../style/Style.js","loc":{"line":25,"column":18,"index":990},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Style.js"},{"name":"../style/Text.js","loc":{"line":26,"column":17,"index":1028},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Text.js"},{"name":"./Vector.js","loc":{"line":27,"column":24,"index":1072},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Vector.js"},{"name":"../source/Vector.js","loc":{"line":28,"column":25,"index":1112},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Vector.js"},{"name":"../extent.js","loc":{"line":29,"column":189,"index":1324},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../obj.js","loc":{"line":30,"column":23,"index":1363},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\obj.js"},{"name":"../math.js","loc":{"line":31,"column":22,"index":1398},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\math.js"},{"name":"../coordinate.js","loc":{"line":32,"column":36,"index":1448},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\coordinate.js"},{"name":"../proj.js","loc":{"line":33,"column":88,"index":1556},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\proj.js"},{"name":"../render.js","loc":{"line":34,"column":33,"index":1603},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render.js"},{"name":"../geom/flat/geodesic.js","loc":{"line":35,"column":35,"index":1654},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Graticule.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\geodesic.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _Collection = _interopRequireDefault(require(\"../Collection.js\"));\nvar _EventType = _interopRequireDefault(require(\"../render/EventType.js\"));\nvar _Feature = _interopRequireDefault(require(\"../Feature.js\"));\nvar _Fill = _interopRequireDefault(require(\"../style/Fill.js\"));\nvar _GeometryLayout = _interopRequireDefault(require(\"../geom/GeometryLayout.js\"));\nvar _LineString = _interopRequireDefault(require(\"../geom/LineString.js\"));\nvar _Point = _interopRequireDefault(require(\"../geom/Point.js\"));\nvar _Stroke = _interopRequireDefault(require(\"../style/Stroke.js\"));\nvar _Style = _interopRequireDefault(require(\"../style/Style.js\"));\nvar _Text = _interopRequireDefault(require(\"../style/Text.js\"));\nvar _Vector = _interopRequireDefault(require(\"./Vector.js\"));\nvar _Vector2 = _interopRequireDefault(require(\"../source/Vector.js\"));\nvar _extent = require(\"../extent.js\");\nvar _obj = require(\"../obj.js\");\nvar _math = require(\"../math.js\");\nvar _coordinate = require(\"../coordinate.js\");\nvar _proj = require(\"../proj.js\");\nvar _render = require(\"../render.js\");\nvar _geodesic = require(\"../geom/flat/geodesic.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/Graticule\n */\n\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nvar DEFAULT_STROKE_STYLE = new _Stroke.default({\n  color: 'rgba(0,0,0,0.2)'\n});\n/**\n * @type {Array<number>}\n * @private\n */\nvar INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom\n * @property {string} text\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle='rgba(0,0,0,0.2)'] The\n * stroke style to use for drawing the graticule. If not provided, a not fully\n * opaque black will be used.\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n */\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\nvar Graticule = /** @class */function (_super) {\n  __extends(Graticule, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  function Graticule(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = (0, _obj.assign)({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    _this = _super.call(this, baseOptions) || this;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.projection_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLat_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLon_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLat_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLon_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxX_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxY_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minX_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minY_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.meridians_ = [];\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.parallels_ = [];\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.fromLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.toLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.projectionCenterLonLat_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomRight_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topRight_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.meridiansLabels_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.parallelsLabels_ = null;\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? _coordinate.degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? _coordinate.degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.lonLabelStyleBase_ = new _Style.default({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new _Text.default({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new _Fill.default({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new _Stroke.default({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.lonLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(_this);\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.latLabelStyleBase_ = new _Style.default({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new _Text.default({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new _Fill.default({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new _Stroke.default({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.latLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(_this);\n      _this.meridiansLabels_ = [];\n      _this.parallelsLabels_ = [];\n      _this.addEventListener(_EventType.default.POSTRENDER, _this.drawLabels_.bind(_this));\n    }\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS;\n    // use a source with a custom loader for lines & text\n    _this.setSource(new _Vector2.default({\n      loader: _this.loaderFunction.bind(_this),\n      strategy: _this.strategyFunction.bind(_this),\n      features: new _Collection.default(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    _this.featurePool_ = [];\n    /**\n     * @type {Style}\n     * @private\n     */\n    _this.lineStyle_ = new _Style.default({\n      stroke: _this.strokeStyle_\n    });\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    _this.loadedExtent_ = null;\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     */\n    _this.renderedExtent_ = null;\n    _this.setRenderOrder(null);\n    return _this;\n  }\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  Graticule.prototype.strategyFunction = function (extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    var realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      (0, _extent.wrapX)(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if ((0, _extent.approximatelyEquals)(this.loadedExtent_, realWorldExtent, resolution)) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  };\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    var source = this.getSource();\n    // only consider the intersection between our own extent & the requested one\n    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n    var renderExtent = (0, _extent.getIntersection)(layerExtent, extent);\n    if (this.renderedExtent_ && (0, _extent.equals)(this.renderedExtent_, renderExtent)) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    // bail out if nothing to render\n    if ((0, _extent.isEmpty)(renderExtent)) {\n      return;\n    }\n    // update projection info\n    var center = (0, _extent.getCenter)(renderExtent);\n    var squaredTolerance = resolution * resolution / 4;\n    var updateProjectionInfo = !this.projection_ || !(0, _proj.equivalent)(this.projection_, projection);\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n    // first make sure we have enough features in the pool\n    var featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n    var feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new _Feature.default();\n      this.featurePool_.push(feature);\n    }\n    var featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    var poolIndex = 0;\n    // add features for the lines & labels\n    var i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n    if ((0, _extent.intersects)(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        var text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new _Point.default([]),\n            text: text\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n    if ((0, _extent.intersects)(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        var text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new _Point.default([]),\n            text: text\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  };\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  Graticule.prototype.drawLabels_ = function (event) {\n    var rotation = event.frameState.viewState.rotation;\n    var extent = event.frameState.extent;\n    var rotationCenter = (0, _extent.getCenter)(extent);\n    var rotationExtent = extent;\n    if (rotation) {\n      var width = (0, _extent.getWidth)(extent);\n      var height = (0, _extent.getHeight)(extent);\n      var cr = Math.abs(Math.cos(rotation));\n      var sr = Math.abs(Math.sin(rotation));\n      var unrotatedWidth = (sr * height - cr * width) / (sr * sr - cr * cr);\n      var unrotatedHeight = (sr * width - cr * height) / (sr * sr - cr * cr);\n      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];\n    }\n    var startWorld = 0;\n    var endWorld = 0;\n    var labelsAtStart = this.latLabelPosition_ < 0.5;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = (0, _extent.getWidth)(projectionExtent);\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      var inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    var vectorContext = (0, _render.getVectorContext)(event);\n    for (var world = startWorld; world <= endWorld; ++world) {\n      var poolIndex = this.meridians_.length + this.parallels_.length;\n      var feature = void 0,\n        index = void 0,\n        l = void 0,\n        textPoint = void 0;\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          var lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            var clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            var lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              var clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n    var interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n    var wrapX = false;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = (0, _extent.getWidth)(projectionExtent);\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {\n      if ((0, _extent.getWidth)(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n    // Constrain the center to fit into the extent available to the graticule\n    var validCenterP = [(0, _math.clamp)(center[0], this.minX_, this.maxX_), (0, _math.clamp)(center[1], this.minY_, this.maxY_)];\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n    var centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n    var centerLon = (0, _math.clamp)(centerLonLat[0], this.minLon_, this.maxLon_);\n    var centerLat = (0, _math.clamp)(centerLonLat[1], this.minLat_, this.maxLat_);\n    var maxLines = this.maxLines_;\n    var cnt, idx, lat, lon;\n    // Limit the extent to fit into the extent available to the graticule\n    var validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [(0, _math.clamp)(extent[0], this.minX_, this.maxX_), (0, _math.clamp)(extent[1], this.minY_, this.maxY_), (0, _math.clamp)(extent[2], this.minX_, this.maxX_), (0, _math.clamp)(extent[3], this.minY_, this.maxY_)];\n    }\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n    var validExtent = (0, _extent.applyTransform)(validExtentP, this.toLonLatTransform_, undefined, 8);\n    var maxLat = validExtent[3];\n    var maxLon = validExtent[2];\n    var minLat = validExtent[1];\n    var minLon = validExtent[0];\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n      if ((0, _extent.containsCoordinate)(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if ((0, _extent.containsCoordinate)(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if ((0, _extent.containsCoordinate)(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if ((0, _extent.containsCoordinate)(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n      // The transformed center may also extend the lon lat ranges used for rendering\n      maxLat = (0, _math.clamp)(maxLat, centerLat, this.maxLat_);\n      maxLon = (0, _math.clamp)(maxLon, centerLon, this.maxLon_);\n      minLat = (0, _math.clamp)(minLat, this.minLat_, centerLat);\n      minLon = (0, _math.clamp)(minLon, this.minLon_, centerLon);\n    }\n    // Create meridians\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = (0, _math.clamp)(centerLon, this.minLon_, this.maxLon_);\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n    lon = (0, _math.clamp)(centerLon, this.minLon_, this.maxLon_);\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n    // Create parallels\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = (0, _math.clamp)(centerLat, this.minLat_, this.maxLat_);\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n    lat = (0, _math.clamp)(centerLat, this.minLat_, this.maxLat_);\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  };\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  Graticule.prototype.getInterval_ = function (resolution) {\n    var centerLon = this.projectionCenterLonLat_[0];\n    var centerLat = this.projectionCenterLonLat_[1];\n    var interval = -1;\n    var target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    var p1 = [];\n    /** @type {Array<number>} **/\n    var p2 = [];\n    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      var delta = (0, _math.clamp)(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      var clampedLat = (0, _math.clamp)(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n    var flatCoordinates = (0, _geodesic.meridian)(lon, minLat, maxLat, this.projection_, squaredTolerance);\n    var lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new _LineString.default(flatCoordinates, _GeometryLayout.default.XY);\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates(_GeometryLayout.default.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var bottom = 1;\n    var top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    var lat = (0, _math.clamp)(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);\n    var coordinate = [coordinate0, lat];\n    var point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  Graticule.prototype.getMeridians = function () {\n    return this.meridians_;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n    var flatCoordinates = (0, _geodesic.parallel)(lat, minLon, maxLon, this.projection_, squaredTolerance);\n    var lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new _LineString.default(flatCoordinates, _GeometryLayout.default.XY);\n    } else {\n      lineString.setFlatCoordinates(_GeometryLayout.default.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var left = 0;\n    var right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    var lon = (0, _math.clamp)(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);\n    var coordinate = [lon, coordinate1];\n    var point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  Graticule.prototype.getParallels = function () {\n    return this.parallels_;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  Graticule.prototype.updateProjectionInfo_ = function (projection) {\n    var epsg4326Projection = (0, _proj.get)('EPSG:4326');\n    var worldExtent = projection.getWorldExtent();\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n    var toLonLatTransform = (0, _proj.getTransform)(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      var split_1 = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {\n        var dimension = opt_dimension || 2;\n        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);\n        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split_1) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n    this.fromLonLatTransform_ = (0, _proj.getTransform)(epsg4326Projection, projection);\n    var worldExtentP = (0, _extent.applyTransform)([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n    this.projectionCenterLonLat_ = this.toLonLatTransform_((0, _extent.getCenter)(projection.getExtent()));\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n    this.projection_ = projection;\n  };\n  return Graticule;\n}(_Vector.default);\nvar _default = exports.default = Graticule;"},"sourceMaps":null,"error":null,"hash":"69e539f39c8d857df80f903bf4cfbf71","cacheData":{"env":{}}}