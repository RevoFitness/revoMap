{"id":"sV2m","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../events/EventType.js","loc":{"line":17,"column":22,"index":645},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\EventType.js"},{"name":"../Feature.js","loc":{"line":18,"column":20,"index":691},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\Feature.js"},{"name":"../geom/GeometryType.js","loc":{"line":19,"column":25,"index":733},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\GeometryType.js"},{"name":"../geom/Point.js","loc":{"line":20,"column":18,"index":778},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\Point.js"},{"name":"./Vector.js","loc":{"line":21,"column":25,"index":823},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Vector.js"},{"name":"../coordinate.js","loc":{"line":22,"column":63,"index":901},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\coordinate.js"},{"name":"../asserts.js","loc":{"line":23,"column":23,"index":944},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\asserts.js"},{"name":"../extent.js","loc":{"line":24,"column":66,"index":1027},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../util.js","loc":{"line":25,"column":23,"index":1066},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Cluster.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\util.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _EventType = _interopRequireDefault(require(\"../events/EventType.js\"));\nvar _Feature = _interopRequireDefault(require(\"../Feature.js\"));\nvar _GeometryType = _interopRequireDefault(require(\"../geom/GeometryType.js\"));\nvar _Point = _interopRequireDefault(require(\"../geom/Point.js\"));\nvar _Vector = _interopRequireDefault(require(\"./Vector.js\"));\nvar _coordinate = require(\"../coordinate.js\");\nvar _asserts = require(\"../asserts.js\");\nvar _extent = require(\"../extent.js\");\nvar _util = require(\"../util.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * @module ol/source/Cluster\n */\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nvar Cluster = /** @class */function (_super) {\n  __extends(Cluster, _super);\n  /**\n   * @param {Options} options Cluster options.\n   */\n  function Cluster(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    _this.resolution = undefined;\n    /**\n     * @type {number}\n     * @protected\n     */\n    _this.distance = options.distance !== undefined ? options.distance : 20;\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    _this.features = [];\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    _this.geometryFunction = options.geometryFunction || function (feature) {\n      var geometry = feature.getGeometry();\n      (0, _asserts.assert)(geometry.getType() == _GeometryType.default.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n      return geometry;\n    };\n    _this.boundRefresh_ = _this.refresh.bind(_this);\n    _this.setSource(options.source || null);\n    return _this;\n  }\n  /**\n   * Remove all features from the source.\n   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n  Cluster.prototype.clear = function (opt_fast) {\n    this.features.length = 0;\n    _super.prototype.clear.call(this, opt_fast);\n  };\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  Cluster.prototype.getDistance = function () {\n    return this.distance;\n  };\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n  Cluster.prototype.getSource = function () {\n    return this.source;\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  };\n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  Cluster.prototype.setDistance = function (distance) {\n    this.distance = distance;\n    this.refresh();\n  };\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource} source The new source for this instance.\n   * @api\n   */\n  Cluster.prototype.setSource = function (source) {\n    if (this.source) {\n      this.source.removeEventListener(_EventType.default.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(_EventType.default.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  };\n  /**\n   * Handle the source changing.\n   */\n  Cluster.prototype.refresh = function () {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  /**\n   * @protected\n   */\n  Cluster.prototype.cluster = function () {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n    var extent = (0, _extent.createEmpty)();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    /**\n     * @type {!Object<string, boolean>}\n     */\n    var clustered = {};\n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n      if (!((0, _util.getUid)(feature) in clustered)) {\n        var geometry = this.geometryFunction(feature);\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          (0, _extent.createOrUpdateFromCoordinate)(coordinates, extent);\n          (0, _extent.buffer)(extent, mapDistance, extent);\n          var neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function (neighbor) {\n            var uid = (0, _util.getUid)(neighbor);\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Feature>} features Features\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  Cluster.prototype.createCluster = function (features) {\n    var centroid = [0, 0];\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        (0, _coordinate.add)(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    (0, _coordinate.scale)(centroid, 1 / features.length);\n    var cluster = new _Feature.default(new _Point.default(centroid));\n    cluster.set('features', features);\n    return cluster;\n  };\n  return Cluster;\n}(_Vector.default);\nvar _default = exports.default = Cluster;"},"sourceMaps":null,"error":null,"hash":"11c83a789d651cfed5cab4adae4c79e8","cacheData":{"env":{}}}