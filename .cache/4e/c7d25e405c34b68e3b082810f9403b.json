{"id":"xlCh","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../color.js","loc":{"line":5,"column":39,"index":133},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\expressions.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\color.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueTypes = exports.Operators = void 0;\nexports.arrayToGlsl = arrayToGlsl;\nexports.colorToGlsl = colorToGlsl;\nexports.expressionToGlsl = expressionToGlsl;\nexports.getStringNumberEquivalent = getStringNumberEquivalent;\nexports.getValueType = getValueType;\nexports.isTypeUnique = isTypeUnique;\nexports.numberToGlsl = numberToGlsl;\nexports.stringToGlsl = stringToGlsl;\nvar _color = require(\"../color.js\");\n/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['zoom']` returns the current zoom level\n *   * `['resolution']` returns the current resolution\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n */\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nvar ValueTypes = exports.ValueTypes = {\n  NUMBER: 1,\n  STRING: 2,\n  COLOR: 4,\n  BOOLEAN: 8,\n  NUMBER_ARRAY: 16,\n  ANY: 31,\n  NONE: 0\n};\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nvar Operators = exports.Operators = {};\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @returns {ValueTypes|number} Type or types inferred from the value\n */\nfunction getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if ((0, _color.isStringColor)(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(\"Unhandled value type: \" + JSON.stringify(value));\n  }\n  var valueArr = /** @type {Array<*>} */value;\n  var onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\"Expected an expression operator but received: \" + JSON.stringify(valueArr));\n  }\n  var operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(valueArr));\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nfunction isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n */\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @returns {string} The value as string.\n */\nfunction numberToGlsl(v) {\n  var s = v.toString();\n  return s.indexOf('.') === -1 ? s + '.0' : s;\n}\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @returns {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nfunction arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return \"vec\" + array.length + \"(\" + array.map(numberToGlsl).join(', ') + \")\";\n}\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @returns {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nfunction colorToGlsl(color) {\n  var array = (0, _color.asArray)(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(array.map(function (c, i) {\n    return i < 3 ? c / 255 : c;\n  }));\n}\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @returns {number} Number equivalent\n */\nfunction getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @returns {string} GLSL-compatible string containing a number\n */\nfunction stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @returns {string} GLSL-compatible output\n */\nfunction expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    var operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(value));\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  } else if ((getValueType(value) & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */value);\n  } else if ((getValueType(value) & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  } else if ((getValueType(value) & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  } else if ((getValueType(value) & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl(/** @type {number[]|string} */value);\n  } else if ((getValueType(value) & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {number[]} */value);\n  }\n}\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\"A numeric value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\nfunction assertNumbers(values) {\n  for (var i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\"A string value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\"A boolean value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\"Exactly \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\"At least \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\"At most \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\"An even amount of arguments was expected, got \" + args + \" instead\");\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\"An even amount of arguments was expected, got \" + args + \" instead\");\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\"Could not infer only one type from the following expression: \" + JSON.stringify(args));\n  }\n}\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.attributes.indexOf(value) === -1) {\n      context.attributes.push(value);\n    }\n    var prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  }\n};\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.variables.indexOf(value) === -1) {\n      context.variables.push(value);\n    }\n    return \"u_\" + value;\n  }\n};\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" * \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" / \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" + \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" - \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    return \"clamp(\" + expressionToGlsl(context, args[0]) + \", \" + min + \", \" + max + \")\";\n  }\n};\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"mod(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"pow(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" > \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" >= \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" < \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" <= \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n      // find common type\n      var type = ValueTypes.ANY;\n      for (var i = 0; i < args.length; i++) {\n        type = type & getValueType(args[i]);\n      }\n      if (type === 0) {\n        throw new Error(\"All arguments should be of compatible type, got \" + JSON.stringify(args) + \" instead\");\n      }\n      return \"(\" + expressionToGlsl(context, args[0], type) + \" \" + operator + \" \" + expressionToGlsl(context, args[1], type) + \")\";\n    }\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return \"(!\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (var i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      var result = '';\n      result = args.map(function (arg) {\n        return expressionToGlsl(context, arg);\n      }).join(\" \" + operator + \" \");\n      result = \"(\" + result + \")\";\n      return result;\n    }\n  };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    var value = expressionToGlsl(context, args[0]);\n    return \"(\" + value + \" >= \" + min + \" && \" + value + \" <= \" + max + \")\";\n  }\n};\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n  }\n};\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var array = /** @type {number[]} */args;\n    if (args.length === 3) {\n      array.push(1);\n    }\n    var parsedArgs = args.map(function (val, i) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');\n    });\n    return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (var i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n    // validate interpolation type\n    var type = args[0];\n    var interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\"Invalid interpolation type for \\\"interpolate\\\" operator, received: \" + JSON.stringify(type));\n    }\n    // compute input/output types\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[1]);\n    var result = null;\n    for (var i = 2; i < args.length - 2; i += 2) {\n      var stop1 = expressionToGlsl(context, args[i]);\n      var output1 = expressionToGlsl(context, args[i + 1], outputType);\n      var stop2 = expressionToGlsl(context, args[i + 2]);\n      var output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = \"mix(\" + (result || output1) + \", \" + output2 + \", pow(clamp((\" + input + \" - \" + stop1 + \") / (\" + stop2 + \" - \" + stop1 + \"), 0.0, 1.0), \" + numberToGlsl(interpolation) + \"))\";\n    }\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.ANY;\n    for (var i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[0]);\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i = args.length - 3; i >= 1; i -= 2) {\n      var match = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\" + input + \" == \" + match + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n    }\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.ANY;\n    for (var i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (var i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i = args.length - 3; i >= 0; i -= 2) {\n      var condition = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\" + condition + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n    }\n    return result;\n  }\n};"},"sourceMaps":null,"error":null,"hash":"85e4910876b9a84cab417125ff75bc30","cacheData":{"env":{}}}