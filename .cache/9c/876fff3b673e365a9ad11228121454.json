{"id":"ngEc","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"./BuilderType.js","loc":{"line":4,"column":24,"index":74},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\BuilderType.js"},{"name":"./Executor.js","loc":{"line":5,"column":21,"index":115},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js"},{"name":"../../extent.js","loc":{"line":6,"column":54,"index":186},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../../transform.js","loc":{"line":7,"column":72,"index":277},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\transform.js"},{"name":"../../dom.js","loc":{"line":8,"column":38,"index":337},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\dom.js"},{"name":"../../obj.js","loc":{"line":9,"column":24,"index":377},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\obj.js"},{"name":"../../array.js","loc":{"line":10,"column":42,"index":435},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\array.js"},{"name":"../../geom/flat/transform.js","loc":{"line":11,"column":28,"index":481},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\transform.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getCircleArray = getCircleArray;\nexports.replayDeclutter = replayDeclutter;\nvar _BuilderType = _interopRequireDefault(require(\"./BuilderType.js\"));\nvar _Executor = _interopRequireDefault(require(\"./Executor.js\"));\nvar _extent = require(\"../../extent.js\");\nvar _transform = require(\"../../transform.js\");\nvar _dom = require(\"../../dom.js\");\nvar _obj = require(\"../../obj.js\");\nvar _array = require(\"../../array.js\");\nvar _transform2 = require(\"../../geom/flat/transform.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * @module ol/render/canvas/ExecutorGroup\n */\n\n/**\n * @const\n * @type {Array<import(\"./BuilderType.js\").default>}\n */\nvar ORDER = [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT];\nvar ExecutorGroup = /** @class */function () {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceet that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Builder.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = (0, _transform.create)();\n    this.createExecutors_(allInstructions);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  ExecutorGroup.prototype.clip = function (context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Builder.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n    for (var zIndex in allInstructions) {\n      var executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      var instructionByZindex = allInstructions[zIndex];\n      var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];\n      for (var builderType in instructionByZindex) {\n        var instructions = instructionByZindex[builderType];\n        executors[builderType] = new _Executor.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);\n      }\n    }\n  };\n  /**\n   * @param {Array<import(\"./BuilderType.js\").default>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  ExecutorGroup.prototype.hasExecutors = function (executors) {\n    for (var zIndex in this.executorsByZIndex_) {\n      var candidates = this.executorsByZIndex_[zIndex];\n      for (var i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = (0, _transform.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    if (!this.hitDetectionContext_) {\n      this.hitDetectionContext_ = (0, _dom.createCanvasContext2D)(contextSize, contextSize);\n    }\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = (0, _extent.createEmpty)();\n      (0, _extent.extendCoordinate)(hitExtent, coordinate);\n      (0, _extent.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var mask = getCircleArray(hitTolerance);\n    var builderType;\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i_1 = 0; i_1 < contextSize; i_1++) {\n        for (var j_1 = 0; j_1 < contextSize; j_1++) {\n          if (mask[i_1][j_1]) {\n            if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {\n              var result_1 = void 0;\n              if (!(declutteredFeatures && (builderType == _BuilderType.default.IMAGE || builderType == _BuilderType.default.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result_1 = callback(feature);\n              }\n              if (result_1) {\n                return result_1;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(_array.numberSafeCompareFunction);\n    var i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  ExecutorGroup.prototype.getClipCoords = function (transform) {\n    var maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    (0, _transform2.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n  ExecutorGroup.prototype.isEmpty = function () {\n    return (0, _obj.isEmpty)(this.executorsByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"./BuilderType.js\").default>=} opt_builderTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(_array.numberSafeCompareFunction);\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        var builderType = builderTypes[j];\n        replay = replays[builderType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (builderType == _BuilderType.default.IMAGE || builderType == _BuilderType.default.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.execute(context, contextScale, transform, viewRotation, snapToPixel);\n          }\n        }\n      }\n    }\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  };\n  return ExecutorGroup;\n}();\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nvar circleArrayCache = {\n  0: [[true]]\n};\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nfunction getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n  var x = radius;\n  var y = 0;\n  var error = 0;\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {number} opacity Opacity.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n * @param {Array<import(\"../../PluggableMap.js\").DeclutterItems>} declutterItems Declutter items.\n */\nfunction replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(_array.numberSafeCompareFunction);\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var executorData = declutterReplays[zs[z].toString()];\n    var currentExecutor = void 0;\n    for (var i = 0, ii = executorData.length; i < ii;) {\n      var executor = executorData[i++];\n      var transform = executorData[i++];\n      executor.execute(context, 1, transform, rotation, snapToPixel);\n      if (executor !== currentExecutor && executor.declutterItems.length > 0) {\n        currentExecutor = executor;\n        declutterItems.push({\n          items: executor.declutterItems,\n          opacity: opacity\n        });\n      }\n    }\n  }\n}\nvar _default = exports.default = ExecutorGroup;"},"sourceMaps":null,"error":null,"hash":"29bfead40073aecc8a50480d3413a5b4","cacheData":{"env":{}}}