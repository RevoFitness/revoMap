{"id":"IFOM","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../geom/GeometryType.js","loc":{"line":4,"column":25,"index":62},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\GeometryType.js"},{"name":"../transform.js","loc":{"line":5,"column":72,"index":161},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\transform.js"},{"name":"../extent.js","loc":{"line":6,"column":103,"index":283},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../array.js","loc":{"line":7,"column":23,"index":322},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\array.js"},{"name":"../geom/flat/interiorpoint.js","loc":{"line":8,"column":72,"index":409},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\interiorpoint.js"},{"name":"../proj.js","loc":{"line":9,"column":37,"index":479},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\proj.js"},{"name":"../geom/flat/interpolate.js","loc":{"line":10,"column":33,"index":526},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\interpolate.js"},{"name":"../geom/flat/center.js","loc":{"line":11,"column":51,"index":608},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\center.js"},{"name":"../geom/flat/transform.js","loc":{"line":12,"column":28,"index":662},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\transform.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _GeometryType = _interopRequireDefault(require(\"../geom/GeometryType.js\"));\nvar _transform = require(\"../transform.js\");\nvar _extent = require(\"../extent.js\");\nvar _array = require(\"../array.js\");\nvar _interiorpoint = require(\"../geom/flat/interiorpoint.js\");\nvar _proj = require(\"../proj.js\");\nvar _interpolate = require(\"../geom/flat/interpolate.js\");\nvar _center = require(\"../geom/flat/center.js\");\nvar _transform2 = require(\"../geom/flat/transform.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * @module ol/render/Feature\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = (0, _transform.create)();\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nvar RenderFeature = /** @class */function () {\n  /**\n   * @param {import(\"../geom/GeometryType.js\").default} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  function RenderFeature(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n    /**\n     * @private\n     * @type {import(\"../geom/GeometryType.js\").default}\n     */\n    this.type_ = type;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>|Array<Array<number>>}\n     */\n    this.ends_ = ends;\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n  }\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  RenderFeature.prototype.get = function (key) {\n    return this.properties_[key];\n  };\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  RenderFeature.prototype.getExtent = function () {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === _GeometryType.default.POINT ? (0, _extent.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0, _extent.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n    return this.extent_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  RenderFeature.prototype.getFlatInteriorPoint = function () {\n    if (!this.flatInteriorPoints_) {\n      var flatCenter = (0, _extent.getCenter)(this.getExtent());\n      this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointOfArray)(this.flatCoordinates_, 0, /** @type {Array<number>} */this.ends_, 2, flatCenter, 0);\n    }\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  RenderFeature.prototype.getFlatInteriorPoints = function () {\n    if (!this.flatInteriorPoints_) {\n      var flatCenters = (0, _center.linearRingss)(this.flatCoordinates_, 0, /** @type {Array<Array<number>>} */this.ends_, 2);\n      this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0, /** @type {Array<Array<number>>} */this.ends_, 2, flatCenters);\n    }\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  RenderFeature.prototype.getFlatMidpoint = function () {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = (0, _interpolate.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n    return this.flatMidpoints_;\n  };\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  RenderFeature.prototype.getFlatMidpoints = function () {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      var flatCoordinates = this.flatCoordinates_;\n      var offset = 0;\n      var ends = /** @type {Array<number>} */this.ends_;\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var midpoint = (0, _interpolate.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);\n        (0, _array.extend)(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  };\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  RenderFeature.prototype.getId = function () {\n    return this.id_;\n  };\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  RenderFeature.prototype.getOrientedFlatCoordinates = function () {\n    return this.flatCoordinates_;\n  };\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  RenderFeature.prototype.getGeometry = function () {\n    return this;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  RenderFeature.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n    return this;\n  };\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  RenderFeature.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n    return this;\n  };\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  RenderFeature.prototype.getProperties = function () {\n    return this.properties_;\n  };\n  /**\n   * @return {number} Stride.\n   */\n  RenderFeature.prototype.getStride = function () {\n    return 2;\n  };\n  /**\n   * @return {undefined}\n   */\n  RenderFeature.prototype.getStyleFunction = function () {\n    return undefined;\n  };\n  /**\n   * Get the type of this feature's geometry.\n   * @return {import(\"../geom/GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  RenderFeature.prototype.getType = function () {\n    return this.type_;\n  };\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   * The SRS of the source and destination are expected to be the same.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.\n   */\n  RenderFeature.prototype.transform = function (source, destination) {\n    source = (0, _proj.get)(source);\n    var pixelExtent = source.getExtent();\n    var projectedExtent = source.getWorldExtent();\n    var scale = (0, _extent.getHeight)(projectedExtent) / (0, _extent.getHeight)(pixelExtent);\n    (0, _transform.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n    (0, _transform2.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n  };\n  /**\n   * @return {Array<number>|Array<Array<number>>} Ends or endss.\n   */\n  RenderFeature.prototype.getEnds = function () {\n    return this.ends_;\n  };\n  return RenderFeature;\n}();\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\nvar _default = exports.default = RenderFeature;"},"sourceMaps":null,"error":null,"hash":"0063ea5fd2a20dd33fddafd2f8b44749","cacheData":{"env":{}}}