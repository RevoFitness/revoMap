{"id":"ohHk","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"./events/Target.js","loc":{"line":17,"column":24,"index":655},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\Target.js"},{"name":"./events/EventType.js","loc":{"line":18,"column":22,"index":699},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\EventType.js"},{"name":"./MapBrowserEvent.js","loc":{"line":19,"column":28,"index":752},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEvent.js"},{"name":"./MapBrowserEventType.js","loc":{"line":20,"column":32,"index":808},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventType.js"},{"name":"./pointer/EventType.js","loc":{"line":21,"column":29,"index":865},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\pointer\\EventType.js"},{"name":"./has.js","loc":{"line":22,"column":60,"index":951},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\has.js"},{"name":"./events.js","loc":{"line":23,"column":38,"index":1001},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\MapBrowserEventHandler.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _Target = _interopRequireDefault(require(\"./events/Target.js\"));\nvar _EventType = _interopRequireDefault(require(\"./events/EventType.js\"));\nvar _MapBrowserEvent = _interopRequireDefault(require(\"./MapBrowserEvent.js\"));\nvar _MapBrowserEventType = _interopRequireDefault(require(\"./MapBrowserEventType.js\"));\nvar _EventType2 = _interopRequireDefault(require(\"./pointer/EventType.js\"));\nvar _has = require(\"./has.js\");\nvar _events = require(\"./events.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * @module ol/MapBrowserEventHandler\n */\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar MapBrowserEventHandler = /** @class */function (_super) {\n  __extends(MapBrowserEventHandler, _super);\n  /**\n   * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n   * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.\n   */\n  function MapBrowserEventHandler(map, moveTolerance) {\n    var _this = _super.call(this, map) || this;\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n    _this.map_ = map;\n    /**\n     * @type {any}\n     * @private\n     */\n    _this.clickTimeoutId_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.dragging_ = false;\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    _this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.moveTolerance_ = moveTolerance ? moveTolerance * _has.DEVICE_PIXEL_RATIO : _has.DEVICE_PIXEL_RATIO;\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.down_ = null;\n    var element = _this.map_.getViewport();\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.activePointers_ = 0;\n    /**\n     * @type {!Object<number, boolean>}\n     * @private\n     */\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.pointerdownListenerKey_ = (0, _events.listen)(element, _EventType2.default.POINTERDOWN, _this.handlePointerDown_, _this);\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.originalPointerMoveEvent_;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.relayedListenerKey_ = (0, _events.listen)(element, _EventType2.default.POINTERMOVE, _this.relayEvent_, _this);\n    /**\n     * @private\n     */\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n    _this.element_.addEventListener(_EventType.default.TOUCHMOVE, _this.boundHandleTouchMove_, _has.PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n    return _this;\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {\n    var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function () {\n        this.clickTimeoutId_ = undefined;\n        var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {\n    var event = pointerEvent;\n    if (event.type == _MapBrowserEventType.default.POINTERUP || event.type == _MapBrowserEventType.default.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == _MapBrowserEventType.default.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(_events.unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    this.down_ = pointerEvent;\n    if (this.dragListenerKeys_.length === 0) {\n      this.dragListenerKeys_.push((0, _events.listen)(document, _MapBrowserEventType.default.POINTERMOVE, this.handlePointerMove_, this), (0, _events.listen)(document, _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      (0, _events.listen)(this.element_, _MapBrowserEventType.default.POINTERCANCEL, this.handlePointerUp_, this));\n      if (this.element_.getRootNode && this.element_.getRootNode() !== document) {\n        this.dragListenerKeys_.push((0, _events.listen)(this.element_.getRootNode(), _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n  };\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserEvent matches the PointerEvent type.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new _MapBrowserEvent.default(pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    if (!this.originalPointerMoveEvent_ || this.originalPointerMoveEvent_.defaultPrevented) {\n      event.preventDefault();\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  /**\n   * Clean up.\n   */\n  MapBrowserEventHandler.prototype.disposeInternal = function () {\n    if (this.relayedListenerKey_) {\n      (0, _events.unlistenByKey)(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(_EventType.default.TOUCHMOVE, this.boundHandleTouchMove_);\n    if (this.pointerdownListenerKey_) {\n      (0, _events.unlistenByKey)(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(_events.unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return MapBrowserEventHandler;\n}(_Target.default);\nvar _default = exports.default = MapBrowserEventHandler;"},"sourceMaps":null,"error":null,"hash":"b8bec5c99a0b5cfb9ed79ff1a1ce1059","cacheData":{"env":{}}}