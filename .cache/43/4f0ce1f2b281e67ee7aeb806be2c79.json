{"id":"N0IJ","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\package.json","includedInParent":true,"mtime":1749531473813},{"name":"ol/events/EventType.js","loc":{"line":1,"column":22,"index":22},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\util.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\EventType.js"},{"name":"ol/render/canvas.js","loc":{"line":2,"column":27,"index":75},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\util.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas.js"},{"name":"ol/events.js","loc":{"line":3,"column":23,"index":121},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\util.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyLetterSpacing = applyLetterSpacing;\nexports.assign = void 0;\nexports.createCanvas = createCanvas;\nexports.defaultResolutions = void 0;\nexports.deg2rad = deg2rad;\nexports.getZoomForResolution = getZoomForResolution;\nexports.wrapText = wrapText;\nvar _EventType = _interopRequireDefault(require(\"ol/events/EventType.js\"));\nvar _canvas = require(\"ol/render/canvas.js\");\nvar _events = require(\"ol/events.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * Polyfill for Object.assign().  Assigns enumerable and own properties from\n * one or more source objects to a target object.\n * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.\n *\n * @param {!Object} target The target object.\n * @param {...Object} var_sources The source object(s).\n * @return {!Object} The modified target object.\n */\nvar assign = exports.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n  var output = Object(target);\n  for (var i = 1, ii = arguments.length; i < ii; ++i) {\n    var source = arguments[i];\n    if (source !== undefined && source !== null) {\n      for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n          output[key] = source[key];\n        }\n      }\n    }\n  }\n  return output;\n};\nfunction deg2rad(degrees) {\n  return degrees * Math.PI / 180;\n}\nvar defaultResolutions = exports.defaultResolutions = function () {\n  var resolutions = [];\n  for (var res = 78271.51696402048; resolutions.length <= 24; res /= 2) {\n    resolutions.push(res);\n  }\n  return resolutions;\n}();\n/**\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @return {HTMLCanvasElement} Canvas.\n */\nfunction createCanvas(width, height) {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && typeof OffscreenCanvas !== 'undefined') {\n    // eslint-disable-line\n    return /** @type {?} */new OffscreenCanvas(width, height);\n  } else {\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\nfunction getZoomForResolution(resolution, resolutions) {\n  var i = 0;\n  var ii = resolutions.length;\n  for (; i < ii; ++i) {\n    var candidate = resolutions[i];\n    if (candidate < resolution && i + 1 < ii) {\n      var zoomFactor = resolutions[i] / resolutions[i + 1];\n      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);\n    }\n  }\n  return ii - 1;\n}\nvar hairSpacePool = Array(256).join('\\u200A');\nfunction applyLetterSpacing(text, letterSpacing) {\n  if (letterSpacing >= 0.05) {\n    var textWithLetterSpacing = '';\n    var lines = text.split('\\n');\n    var joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));\n    for (var l = 0, ll = lines.length; l < ll; ++l) {\n      if (l > 0) {\n        textWithLetterSpacing += '\\n';\n      }\n      textWithLetterSpacing += lines[l].split('').join(joinSpaceString);\n    }\n    return textWithLetterSpacing;\n  }\n  return text;\n}\nvar measureContext;\nfunction getMeasureContext() {\n  if (!measureContext) {\n    measureContext = createCanvas(1, 1).getContext('2d');\n  }\n  return measureContext;\n}\nfunction measureText(text, letterSpacing) {\n  return getMeasureContext().measureText(text).width + (text.length - 1) * letterSpacing;\n}\nvar measureCache = {};\nif (_canvas.labelCache) {\n  // Only available when using ES modules\n  //@ts-ignore\n  (0, _events.listen)(_canvas.labelCache, _EventType.default.CLEAR, function () {\n    measureCache = {};\n  });\n}\nfunction wrapText(text, font, em, letterSpacing) {\n  if (text.indexOf('\\n') !== -1) {\n    var hardLines = text.split('\\n');\n    var lines = [];\n    for (var i = 0, ii = hardLines.length; i < ii; ++i) {\n      lines.push(wrapText(hardLines[i], font, em, letterSpacing));\n    }\n    return lines.join('\\n');\n  }\n  var key = em + ',' + font + ',' + text + ',' + letterSpacing;\n  var wrappedText = measureCache[key];\n  if (!wrappedText) {\n    var words = text.split(' ');\n    if (words.length > 1) {\n      var ctx = getMeasureContext();\n      ctx.font = font;\n      var oneEm = ctx.measureText('M').width;\n      var maxWidth = oneEm * em;\n      var line = '';\n      var lines = [];\n      // Pass 1 - wrap lines to not exceed maxWidth\n      for (var i = 0, ii = words.length; i < ii; ++i) {\n        var word = words[i];\n        var testLine = line + (line ? ' ' : '') + word;\n        if (measureText(testLine, letterSpacing) <= maxWidth) {\n          line = testLine;\n        } else {\n          if (line) {\n            lines.push(line);\n          }\n          line = word;\n        }\n      }\n      if (line) {\n        lines.push(line);\n      }\n      // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line\n      for (var i = 0, ii = lines.length; i < ii && ii > 1; ++i) {\n        var line_1 = lines[i];\n        if (measureText(line_1, letterSpacing) < maxWidth * 0.35) {\n          var prevWidth = i > 0 ? measureText(lines[i - 1], letterSpacing) : Infinity;\n          var nextWidth = i < ii - 1 ? measureText(lines[i + 1], letterSpacing) : Infinity;\n          lines.splice(i, 1);\n          ii -= 1;\n          if (prevWidth < nextWidth) {\n            lines[i - 1] += ' ' + line_1;\n            i -= 1;\n          } else {\n            lines[i] = line_1 + ' ' + lines[i];\n          }\n        }\n      }\n      // Pass 3 - try to fill 80% of maxWidth for each line\n      for (var i = 0, ii = lines.length - 1; i < ii; ++i) {\n        var line_2 = lines[i];\n        var next = lines[i + 1];\n        if (measureText(line_2, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {\n          var lineWords = line_2.split(' ');\n          var lastWord = lineWords.pop();\n          if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {\n            lines[i] = lineWords.join(' ');\n            lines[i + 1] = lastWord + ' ' + next;\n          }\n          ii -= 1;\n        }\n      }\n      wrappedText = lines.join('\\n');\n    } else {\n      wrappedText = text;\n    }\n    wrappedText = applyLetterSpacing(wrappedText, letterSpacing);\n    measureCache[key] = wrappedText;\n  }\n  return wrappedText;\n}"},"sourceMaps":null,"error":null,"hash":"bca2847dd909a850fecc37e46f503529","cacheData":{"env":{}}}