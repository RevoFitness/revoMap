{"id":"pZKE","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"./Instruction.js","loc":{"line":4,"column":30,"index":75},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Instruction.js"},{"name":"rbush/rbush.js","loc":{"line":5,"column":18,"index":113},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\rbush\\rbush.js"},{"name":"./TextBuilder.js","loc":{"line":6,"column":27,"index":158},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js"},{"name":"../../has.js","loc":{"line":7,"column":40,"index":218},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\has.js"},{"name":"../../transform.js","loc":{"line":8,"column":136,"index":370},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\transform.js"},{"name":"../../extent.js","loc":{"line":9,"column":78,"index":470},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../canvas.js","loc":{"line":11,"column":98,"index":674},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas.js"},{"name":"../../geom/flat/textpath.js","loc":{"line":12,"column":31,"index":721},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\textpath.js"},{"name":"../../array.js","loc":{"line":13,"column":23,"index":775},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\array.js"},{"name":"../../geom/flat/length.js","loc":{"line":14,"column":33,"index":826},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\length.js"},{"name":"../../geom/flat/transform.js","loc":{"line":15,"column":28,"index":883},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Executor.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\transform.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _Instruction = _interopRequireDefault(require(\"./Instruction.js\"));\nvar _rbush = _interopRequireDefault(require(\"rbush/rbush.js\"));\nvar _TextBuilder = require(\"./TextBuilder.js\");\nvar _has = require(\"../../has.js\");\nvar _transform = require(\"../../transform.js\");\nvar _extent = require(\"../../extent.js\");\nvar _canvas = require(\"../canvas.js\");\nvar _textpath = require(\"../../geom/flat/textpath.js\");\nvar _array = require(\"../../array.js\");\nvar _length = require(\"../../geom/flat/length.js\");\nvar _transform2 = require(\"../../geom/flat/transform.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * @module ol/render/canvas/Executor\n */\n\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} textStates The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} fillStates The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} strokeStates The stroke states (decluttering).\n */\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = (0, _extent.createEmpty)();\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\nvar tmpTransform = (0, _transform.create)();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\nvar Executor = /** @class */function () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {SerializableInstructions} instructions The serializable instructions\n   * @param {import(\"../../size.js\").Size} renderBuffer Render buffer (width/height) in pixels.\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n    /**\n     * @type {Array<*>}\n     */\n    this.declutterItems = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {import(\"../../size.js\").Size}\n     */\n    this.renderBuffer_ = renderBuffer;\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = (0, _transform.create)();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n    this.labels_ = {};\n  }\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n    var key = text + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    var align = _TextBuilder.TEXT_ALIGN[textState.textAlign || _canvas.defaultTextAlign];\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var lines = text.split('\\n');\n    var numLines = lines.length;\n    var widths = [];\n    var width = (0, _canvas.measureTextWidths)(textState.font, lines, widths);\n    var lineHeight = (0, _canvas.measureTextHeight)(textState.font);\n    var height = lineHeight * numLines;\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = [];\n    // make canvas 2 pixels wider to account for italic text width measurement errors\n    var w = (renderWidth + 2) * scale[0];\n    var h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n    var label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n    contextInstructions.push('font', textState.font);\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      // eslint-disable-next-line\n      var Context = _has.WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    var leftRight = 0.5 - align;\n    var x = align * renderWidth + leftRight * strokeWidth;\n    var i;\n    if (strokeKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n    if (fillKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n    this.labels_[key] = label;\n    return label;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @param {boolean} declutter Declutter.\n   */\n  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction, declutter) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */fillInstruction[2];\n      if (declutter) {\n        context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */fillInstruction[1];\n      }\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array<*>} */strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    x -= anchorX;\n    y -= anchorY;\n    var w = width + originX > imageOrLabel.width ? imageOrLabel.width - originX : width;\n    var h = height + originY > imageOrLabel.height ? imageOrLabel.height - originY : height;\n    var boxW = padding[3] + w * scale[0] + padding[1];\n    var boxH = padding[0] + h * scale[1] + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n    var transform = null;\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = (0, _transform.compose)(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      (0, _transform.apply)(tmpTransform, p1);\n      (0, _transform.apply)(tmpTransform, p2);\n      (0, _transform.apply)(tmpTransform, p3);\n      (0, _transform.apply)(tmpTransform, p4);\n      (0, _extent.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      (0, _extent.createOrUpdate)(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n    var renderBufferX = 0;\n    var renderBufferY = 0;\n    if (declutterGroup) {\n      var renderBuffer = this.renderBuffer_;\n      renderBuffer[0] = Math.max(renderBuffer[0], (0, _extent.getWidth)(tmpExtent));\n      renderBufferX = renderBuffer[0];\n      renderBuffer[1] = Math.max(renderBuffer[1], (0, _extent.getHeight)(tmpExtent));\n      renderBufferY = renderBuffer[1];\n    }\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale[0] / 2 : 0;\n    var intersects = tmpExtent[0] - strokePadding <= (canvas.width + renderBufferX) / contextScale && tmpExtent[2] + strokePadding >= -renderBufferX / contextScale && tmpExtent[1] - strokePadding <= (canvas.height + renderBufferY) / contextScale && tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[0] == 1) {\n        return false;\n      }\n      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, imageOrLabel, originX, originY, w, h, x, y, scale, tmpExtent.slice()] : null;\n      if (declutterArgs) {\n        if (fillStroke) {\n          declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));\n        }\n        declutterGroup.push(declutterArgs);\n      }\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */fillInstruction, /** @type {Array<*>} */strokeInstruction, false);\n      }\n      (0, _canvas.drawImageOrLabel)(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);\n    }\n    return true;\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  Executor.prototype.fill_ = function (context) {\n    if (this.alignFill_) {\n      var origin_1 = (0, _transform.apply)(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n    context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n    context.lineWidth = /** @type {number} */instruction[2];\n    context.lineCap = /** @type {CanvasLineCap} */instruction[3];\n    context.lineJoin = /** @type {CanvasLineJoin} */instruction[4];\n    context.miterLimit = /** @type {number} */instruction[5];\n    if (context.setLineDash) {\n      context.lineDashOffset = /** @type {number} */instruction[7];\n      context.setLineDash(/** @type {Array<number>} */instruction[6]);\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} opacity Layer opacity.\n   * @param {?} declutterTree Declutter tree.\n   * @return {?} Declutter tree.\n   */\n  Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {\n    /** @type {Array<import(\"../../structs/RBush.js\").Entry>} */\n    var boxes = [];\n    for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {\n      var declutterData = declutterGroup[i];\n      var box = declutterData[11];\n      boxes.push({\n        minX: box[0],\n        minY: box[1],\n        maxX: box[2],\n        maxY: box[3],\n        value: feature\n      });\n    }\n    if (!declutterTree) {\n      declutterTree = new _rbush.default(9);\n    }\n    var collides = false;\n    for (var i = 0, ii = boxes.length; i < ii; ++i) {\n      if (declutterTree.collides(boxes[i])) {\n        collides = true;\n        break;\n      }\n    }\n    if (!collides) {\n      declutterTree.load(boxes);\n      for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {\n        var declutterData = /** @type {Array} */declutterGroup[j];\n        var context = declutterData[0];\n        var currentAlpha = context.globalAlpha;\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = opacity;\n        }\n        if (declutterData.length > 12) {\n          this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);\n        }\n        _canvas.drawImageOrLabel.apply(undefined, declutterData);\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = currentAlpha;\n        }\n      }\n    }\n    declutterGroup.length = 1;\n    return declutterTree;\n  };\n  /**\n   * @private\n   * @param {string} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = _TextBuilder.TEXT_ALIGN[textState.textAlign || _canvas.defaultTextAlign];\n    var baseline = _TextBuilder.TEXT_ALIGN[textState.textBaseline || _canvas.defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    // Remove the 2 pixels we added in createLabel() for the anchor\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T|undefined} featureCallback Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n    this.declutterItems.length = 0;\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n    if (this.pixelCoordinates_ && (0, _array.equals)(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = (0, _transform2.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      (0, _transform.setFromArray)(this.renderedTransform_, transform);\n    }\n    var i = 0; // instruction index\n    var ii = instructions.length; // end of instructions\n    var d = 0; // data index\n    var dd; // end of per-instruction data\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;\n    var strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    var state = /** @type {import(\"../../render.js\").State} */{\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    };\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var /** @type {import(\"../../Feature.js\").FeatureLike} */feature;\n    var x, y;\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = /** @type {import(\"./Instruction.js\").default} */instruction[0];\n      switch (type) {\n        case _Instruction.default.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */instruction[1];\n          if (!feature.getGeometry()) {\n            i = /** @type {number} */instruction[2];\n          } else if (opt_hitExtent !== undefined && !(0, _extent.intersects)(opt_hitExtent, instruction[3])) {\n            i = /** @type {number} */instruction[2] + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case _Instruction.default.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i;\n          break;\n        case _Instruction.default.CIRCLE:\n          d = /** @type {number} */instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case _Instruction.default.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case _Instruction.default.CUSTOM:\n          d = /** @type {number} */instruction[1];\n          dd = instruction[2];\n          var geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          var coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case _Instruction.default.DRAW_IMAGE:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */instruction[3];\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */instruction[4];\n          anchorY = /** @type {number} */instruction[5];\n          declutterGroups = featureCallback ? null : instruction[6];\n          var height = /** @type {number} */instruction[7];\n          var opacity = /** @type {number} */instruction[8];\n          var originX = /** @type {number} */instruction[9];\n          var originY = /** @type {number} */instruction[10];\n          var rotateWithView = /** @type {boolean} */instruction[11];\n          var rotation = /** @type {number} */instruction[12];\n          var scale = /** @type {import(\"../../size.js\").Size} */instruction[13];\n          var width = /** @type {number} */instruction[14];\n          if (!image && instruction.length >= 19) {\n            // create label images\n            text = /** @type {string} */instruction[18];\n            textKey = /** @type {string} */instruction[19];\n            strokeKey = /** @type {string} */instruction[20];\n            fillKey = /** @type {string} */instruction[21];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            var textOffsetX = /** @type {number} */instruction[22];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY = /** @type {number} */instruction[23];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[7] = height;\n            width = image.width;\n            instruction[14] = width;\n          }\n          var geometryWidths = void 0;\n          if (instruction.length > 24) {\n            geometryWidths = /** @type {number} */instruction[24];\n          }\n          var padding = void 0,\n            backgroundFill = void 0,\n            backgroundStroke = void 0;\n          if (instruction.length > 16) {\n            padding = /** @type {Array<number>} */instruction[15];\n            backgroundFill = /** @type {boolean} */instruction[16];\n            backgroundStroke = /** @type {boolean} */instruction[17];\n          } else {\n            padding = _canvas.defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n          var widthIndex = 0;\n          var declutterGroupIndex = 0;\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n            if (declutterGroups) {\n              var index = Math.floor(declutterGroupIndex);\n              declutterGroup = declutterGroups.length < index + 1 ? [declutterGroups[0][0]] : declutterGroups[index];\n            }\n            var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? (/** @type {Array<*>} */lastFillInstruction) : null, backgroundStroke ? (/** @type {Array<*>} */lastStrokeInstruction) : null);\n            if (rendered && declutterGroup && declutterGroups[declutterGroups.length - 1] !== declutterGroup) {\n              declutterGroups.push(declutterGroup);\n            }\n            if (declutterGroup) {\n              if (declutterGroup.length - 1 === declutterGroup[0]) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n              declutterGroupIndex += 1 / declutterGroup[0];\n            }\n          }\n          ++i;\n          break;\n        case _Instruction.default.DRAW_CHARS:\n          var begin = /** @type {number} */instruction[1];\n          var end = /** @type {number} */instruction[2];\n          var baseline = /** @type {number} */instruction[3];\n          declutterGroup = featureCallback ? null : instruction[4];\n          var overflow = /** @type {number} */instruction[5];\n          fillKey = /** @type {string} */instruction[6];\n          var maxAngle = /** @type {number} */instruction[7];\n          var measurePixelRatio = /** @type {number} */instruction[8];\n          var offsetY = /** @type {number} */instruction[9];\n          strokeKey = /** @type {string} */instruction[10];\n          var strokeWidth = /** @type {number} */instruction[11];\n          text = /** @type {string} */instruction[12];\n          textKey = /** @type {string} */instruction[13];\n          var pixelRatioScale = [(/** @type {number} */instruction[14]), (/** @type {number} */instruction[14])];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          var cachedWidths = void 0;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n          var pathLength = (0, _length.lineStringLength)(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * (0, _canvas.measureAndCacheTextWidth)(font, text, cachedWidths);\n          if (overflow || textLength <= pathLength) {\n            var textAlign = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * _TextBuilder.TEXT_ALIGN[textAlign];\n            var parts = (0, _textpath.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), _canvas.measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n            if (parts) {\n              var rendered = false;\n              var c = void 0,\n                cc = void 0,\n                chars = void 0,\n                label = void 0,\n                part = void 0;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */part[2] + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  rendered = this.replayImageOrLabel_(context, contextScale, /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, /** @type {number} */part[3], pixelRatioScale, false, label.width, _canvas.defaultPadding, null, null) || rendered;\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  rendered = this.replayImageOrLabel_(context, contextScale, /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, /** @type {number} */part[3], pixelRatioScale, false, label.width, _canvas.defaultPadding, null, null) || rendered;\n                }\n              }\n              if (rendered) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n            }\n          }\n          ++i;\n          break;\n        case _Instruction.default.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */instruction[1];\n            var result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case _Instruction.default.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case _Instruction.default.MOVE_TO_LINE_TO:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case _Instruction.default.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n          context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n          ++i;\n          break;\n        case _Instruction.default.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */instruction);\n          ++i;\n          break;\n        case _Instruction.default.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n  return Executor;\n}();\nvar _default = exports.default = Executor;"},"sourceMaps":null,"error":null,"hash":"0cbcc71c0d3976e4b4c78317385439ea","cacheData":{"env":{}}}