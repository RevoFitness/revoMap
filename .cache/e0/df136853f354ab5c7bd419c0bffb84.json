{"id":"UST7","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../../render/canvas/BuilderGroup.js","loc":{"line":17,"column":31,"index":671},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\BuilderGroup.js"},{"name":"../../render/canvas/ExecutorGroup.js","loc":{"line":18,"column":54,"index":764},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\ExecutorGroup.js"},{"name":"./TileLayer.js","loc":{"line":19,"column":36,"index":840},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\TileLayer.js"},{"name":"../../events/EventType.js","loc":{"line":20,"column":22,"index":880},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\EventType.js"},{"name":"../../render/canvas/BuilderType.js","loc":{"line":21,"column":23,"index":932},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\BuilderType.js"},{"name":"../../TileState.js","loc":{"line":22,"column":22,"index":992},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\TileState.js"},{"name":"../../layer/VectorTileRenderType.js","loc":{"line":23,"column":33,"index":1047},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\VectorTileRenderType.js"},{"name":"../../ViewHint.js","loc":{"line":24,"column":21,"index":1107},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\ViewHint.js"},{"name":"../../transform.js","loc":{"line":25,"column":168,"index":1296},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\transform.js"},{"name":"../../extent.js","loc":{"line":26,"column":109,"index":1427},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../../obj.js","loc":{"line":27,"column":22,"index":1468},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\obj.js"},{"name":"../../render/canvas/hitdetect.js","loc":{"line":28,"column":56,"index":1540},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\hitdetect.js"},{"name":"../vector.js","loc":{"line":29,"column":81,"index":1657},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\vector.js"},{"name":"../../util.js","loc":{"line":30,"column":23,"index":1696},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\util.js"},{"name":"../../events.js","loc":{"line":31,"column":38,"index":1751},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events.js"},{"name":"../../size.js","loc":{"line":32,"column":23,"index":1793},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\size.js"},{"name":"../../coordinate.js","loc":{"line":33,"column":22,"index":1832},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\renderer\\canvas\\VectorTileLayer.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\coordinate.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _BuilderGroup = _interopRequireDefault(require(\"../../render/canvas/BuilderGroup.js\"));\nvar _ExecutorGroup = _interopRequireWildcard(require(\"../../render/canvas/ExecutorGroup.js\"));\nvar _TileLayer = _interopRequireDefault(require(\"./TileLayer.js\"));\nvar _EventType = _interopRequireDefault(require(\"../../events/EventType.js\"));\nvar _BuilderType = _interopRequireDefault(require(\"../../render/canvas/BuilderType.js\"));\nvar _TileState = _interopRequireDefault(require(\"../../TileState.js\"));\nvar _VectorTileRenderType = _interopRequireDefault(require(\"../../layer/VectorTileRenderType.js\"));\nvar _ViewHint = _interopRequireDefault(require(\"../../ViewHint.js\"));\nvar _transform = require(\"../../transform.js\");\nvar _extent = require(\"../../extent.js\");\nvar _obj = require(\"../../obj.js\");\nvar _hitdetect = require(\"../../render/canvas/hitdetect.js\");\nvar _vector = require(\"../vector.js\");\nvar _util = require(\"../../util.js\");\nvar _events = require(\"../../events.js\");\nvar _size = require(\"../../size.js\");\nvar _coordinate = require(\"../../coordinate.js\");\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n  'image': [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT],\n  'hybrid': [_BuilderType.default.POLYGON, _BuilderType.default.LINE_STRING],\n  'vector': []\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n  'image': [_BuilderType.default.DEFAULT],\n  'hybrid': [_BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT],\n  'vector': [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /** @class */function (_super) {\n  __extends(CanvasVectorTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this = _super.call(this, layer) || this;\n    /** @private */\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    _this.renderedPixelToCoordinateTransform_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedRotation_;\n    /**\n     * @private\n     * @type {!Object<string, import(\"../../VectorRenderTile.js\").default>}\n     */\n    _this.renderTileImageQueue_ = {};\n    /**\n     * @type {Object<string, import(\"../../events.js\").EventsKey>}\n     */\n    _this.tileListenerKeys_ = {};\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.tmpTransform_ = (0, _transform.create)();\n    return _this;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @param {boolean} queue Queue tile for rendering.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection, queue) {\n    var render;\n    var tileUid = (0, _util.getUid)(tile);\n    var state = tile.getState();\n    if ((state === _TileState.default.LOADED && tile.hifi || state === _TileState.default.ERROR) && tileUid in this.tileListenerKeys_) {\n      (0, _events.unlistenByKey)(this.tileListenerKeys_[tileUid]);\n      delete this.tileListenerKeys_[tileUid];\n    }\n    if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {\n        render = true;\n        if (queue) {\n          this.renderTileImageQueue_[tileUid] = tile;\n        }\n      }\n    }\n    return render;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    var layer = this.getLayer();\n    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() < _TileState.default.LOADED) {\n      tile.wantedResolution = resolution;\n      var tileUid = (0, _util.getUid)(tile);\n      if (!(tileUid in this.tileListenerKeys_)) {\n        var listenerKey = (0, _events.listen)(tile, _EventType.default.CHANGE, this.prepareTile.bind(this, tile, pixelRatio, projection, true));\n        this.tileListenerKeys_[tileUid] = listenerKey;\n      }\n    } else {\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);\n      if (hifi || !tile.wantedResolution) {\n        tile.wantedResolution = resolution;\n      }\n      var render = this.prepareTile(tile, pixelRatio, projection, false);\n      if (render && layer.getRenderMode() !== _VectorTileRenderType.default.VECTOR) {\n        this.renderTileImage_(tile, frameState);\n      }\n    }\n    return _super.prototype.getTile.call(this, z, x, y, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var layer = this.getLayer();\n    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === _VectorTileRenderType.default.VECTOR ? (0, _util.getUid)(layer) in tile.executorGroups : tile.hasContext(layer));\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage(this.getLayer());\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile.wantedResolution;\n    var builderState = tile.getReplayState(layer);\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder && builderState.renderedZ === tile.sourceZ) {\n      return;\n    }\n    var source = layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    var layerUid = (0, _util.getUid)(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    var _loop_1 = function (t, tt) {\n      var sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != _TileState.default.LOADED) {\n        return \"continue\";\n      }\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = (0, _extent.getIntersection)(tileExtent, sourceTileExtent);\n      var bufferedExtent = (0, _extent.equals)(sourceTileExtent, sharedExtent) ? null : (0, _extent.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      builderState.dirty = false;\n      var builderGroup = new _BuilderGroup.default(0, sharedExtent, resolution, pixelRatio, layer.getDeclutter());\n      var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n        if (!bufferedExtent || (0, _extent.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this_1, feature);\n        }\n      }\n      var executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      var replayExtent = layer.getRenderMode() !== _VectorTileRenderType.default.VECTOR && layer.getDeclutter() && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new _ExecutorGroup.default(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    };\n    var this_1 = this;\n    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      _loop_1(t, tt);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedZ = tile.sourceZ;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../layer/Layer.js\").default): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    var declutter = layer.getDeclutter();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    /** @type {!Object<string, boolean>} */\n    var features = {};\n    var renderedTiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */this.renderedTiles;\n    var found;\n    var i, ii;\n    var _loop_2 = function () {\n      var tile = renderedTiles[i];\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var tileContainsCoordinate = (0, _extent.containsCoordinate)(tileExtent, coordinate);\n      if (!declutter) {\n        // When not decluttering, we only need to consider the tile that contains the given\n        // coordinate, because each feature will be rendered for each tile that contains it.\n        if (!tileContainsCoordinate) {\n          return \"continue\";\n        }\n      }\n      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        found = found || executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance,\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          if (tileContainsCoordinate || declutteredFeatures && declutteredFeatures.indexOf(feature) !== -1) {\n            var key = feature.getId();\n            if (key === undefined) {\n              key = (0, _util.getUid)(feature);\n            }\n            if (!(key in features)) {\n              features[key] = true;\n              return callback(feature, layer);\n            }\n          }\n        }, layer.getDeclutter() ? declutteredFeatures : null);\n      }\n    };\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      _loop_2();\n    }\n    return found;\n  };\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n    return new Promise(function (resolve, reject) {\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n      var layerUid = (0, _util.getUid)(layer);\n      var source = layer.getSource();\n      var projection = this.renderedProjection;\n      var projectionExtent = projection.getExtent();\n      var resolution = this.renderedResolution;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var coordinate = (0, _transform.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      var tile;\n      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = this.renderedTiles[i];\n          if (tile.getState() === _TileState.default.LOADED && tile.hifi) {\n            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (source.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent_1)) {\n              (0, _coordinate.wrapX)(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var corner = (0, _extent.getTopLeft)(extent);\n      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n        var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n        var size = [tileSize[0] / 2, tileSize[1] / 2];\n        var rotation = this.renderedRotation_;\n        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, 0.5, size[0], size[1], 0)];\n        hitDetectionImageData = (0, _hitdetect.createHitDetectionImageData)(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve((0, _hitdetect.hitDetect)(tilePixel, features, hitDetectionImageData));\n    }.bind(this));\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n    (0, _obj.clear)(this.renderTileImageQueue_);\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);\n    this.renderQueuedTileImages_(hifi, frameState);\n    _super.prototype.renderFrame.call(this, frameState, target);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var renderMode = layer.getRenderMode();\n    if (renderMode === _VectorTileRenderType.default.IMAGE) {\n      return this.container;\n    }\n    var source = layer.getSource();\n    // Unqueue tiles from the image queue when we don't need any more\n    var usedTiles = frameState.usedTiles[(0, _util.getUid)(source)];\n    for (var tileUid in this.renderTileImageQueue_) {\n      if (!usedTiles || !(tileUid in usedTiles)) {\n        delete this.renderTileImageQueue_[tileUid];\n      }\n    }\n    var context = this.context;\n    var declutterReplays = layer.getDeclutter() ? {} : null;\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var rotation = viewState.rotation;\n    var size = frameState.size;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var tiles = this.renderedTiles;\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var clips = [];\n    var clipZs = [];\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */tiles[i];\n      var tileCoord = tile.tileCoord;\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n      var transform = (0, _transform.multiply)((0, _transform.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];\n      var clipped = false;\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n        var currentZ = tile.tileCoord[0];\n        var currentClip = void 0;\n        if (!declutterReplays && !clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n          context.save();\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n            if (currentZ < clipZs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes, declutterReplays);\n        if (!declutterReplays && !clipped) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n    if (declutterReplays) {\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      (0, _ExecutorGroup.replayDeclutter)(declutterReplays, context, rotation, layerState.opacity, hifi, frameState.declutterItems);\n    }\n    return this.container;\n  };\n  /**\n   * @param {boolean} hifi We have time to render a high fidelity map image.\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderQueuedTileImages_ = function (hifi, frameState) {\n    // When we don't have time to render hifi, only render tiles until we have used up\n    // half of the frame budget of 16 ms\n    for (var uid in this.renderTileImageQueue_) {\n      if (!hifi && Date.now() - frameState.time > 8) {\n        frameState.animate = true;\n        break;\n      }\n      var tile = this.renderTileImageQueue_[uid];\n      delete this.renderTileImageQueue_[uid];\n      this.renderTileImage_(tile, frameState);\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} executorGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, executorGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = (0, _vector.renderFeature)(executorGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_) || loading;\n      }\n    } else {\n      loading = (0, _vector.renderFeature)(executorGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_);\n    }\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var sourceZ = tile.sourceZ;\n    var resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision || replayState.renderedTileZ !== sourceZ;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];\n    replayState.renderedTileRevision = revision;\n    replayState.renderedTileZ = tile.sourceZ;\n    var tileCoord = tile.wrappedTileCoord;\n    var z = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z);\n    var context = tile.getContext(layer);\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.max(pixelRatio, renderPixelRatio / pixelRatio);\n    var size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      var canvasTransform = (0, _transform.reset)(this.tmpTransform_);\n      (0, _transform.scale)(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform = (0, _transform.reset)(this.tmpTransform_);\n    (0, _transform.scale)(transform, pixelScale, -pixelScale);\n    (0, _transform.translate)(transform, -tileExtent[0], -tileExtent[3]);\n    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n      var executorGroup = executorGroups[i];\n      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  };\n  return CanvasVectorTileLayerRenderer;\n}(_TileLayer.default);\nvar _default = exports.default = CanvasVectorTileLayerRenderer;"},"sourceMaps":null,"error":null,"hash":"fc06c1d2e79015c7f340b9676d07c610","cacheData":{"env":{}}}