{"id":"iRdz","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../style/expressions.js","loc":{"line":5,"column":73,"index":190},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\webgl\\ShaderBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\expressions.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ShaderBuilder = void 0;\nexports.parseLiteralStyle = parseLiteralStyle;\nvar _expressions = require(\"../style/expressions.js\");\n/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nvar ShaderBuilder = exports.ShaderBuilder = /** @class */function () {\n  function ShaderBuilder() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addUniform = function (name) {\n    this.uniforms.push(name);\n    return this;\n  };\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addAttribute = function (name) {\n    this.attributes.push(name);\n    return this;\n  };\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addVarying = function (name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  };\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSizeExpression = function (expression) {\n    this.sizeExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setRotationExpression = function (expression) {\n    this.rotationExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {\n    this.offsetExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setColorExpression = function (expression) {\n    this.colorExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {\n    this.texCoordExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {\n    this.discardExpression = expression;\n    return this;\n  };\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  };\n  /**\n   * @returns {string} Previously set size expression\n   */\n  ShaderBuilder.prototype.getSizeExpression = function () {\n    return this.sizeExpression;\n  };\n  /**\n   * @returns {string} Previously set symbol offset expression\n   */\n  ShaderBuilder.prototype.getOffsetExpression = function () {\n    return this.offsetExpression;\n  };\n  /**\n   * @returns {string} Previously set color expression\n   */\n  ShaderBuilder.prototype.getColorExpression = function () {\n    return this.colorExpression;\n  };\n  /**\n   * @returns {string} Previously set texture coordinate expression\n   */\n  ShaderBuilder.prototype.getTextureCoordinateExpression = function () {\n    return this.texCoordExpression;\n  };\n  /**\n   * @returns {string} Previously set fragment discard expression\n   */\n  ShaderBuilder.prototype.getFragmentDiscardExpression = function () {\n    return this.discardExpression;\n  };\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @returns {string} The full shader as a string.\n   */\n  ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {\n    var offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    var attributes = this.attributes;\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n') + \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\" + attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n') + \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \" + offsetMatrix + \";\\n  vec2 halfSize = \" + this.sizeExpression + \" * 0.5;\\n  vec2 offset = \" + this.offsetExpression + \";\\n  float angle = \" + this.rotationExpression + \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \" + this.texCoordExpression + \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\" + varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n') + \"\\n}\";\n  };\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @returns {string} The full shader as a string.\n   */\n  ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {\n    var hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n') + \"\\nvoid main(void) {\\n  if (\" + this.discardExpression + \") { discard; }\\n  gl_FragColor = \" + this.colorExpression + \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\" + hitDetectionBypass + \"\\n}\";\n  };\n  return ShaderBuilder;\n}();\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object.<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n/**\n * Parses a {@link import(\"../style/LiteralStyle\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/LiteralStyle\").LiteralStyle} style Literal style.\n * @returns {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nfunction parseLiteralStyle(style) {\n  var symbStyle = style.symbol;\n  var size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  var color = symbStyle.color || 'white';\n  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  var offset = symbStyle.offset || [0, 0];\n  var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  var vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {}\n  };\n  var parsedSize = (0, _expressions.expressionToGlsl)(vertContext, size, _expressions.ValueTypes.NUMBER_ARRAY | _expressions.ValueTypes.NUMBER);\n  var parsedOffset = (0, _expressions.expressionToGlsl)(vertContext, offset, _expressions.ValueTypes.NUMBER_ARRAY);\n  var parsedTexCoord = (0, _expressions.expressionToGlsl)(vertContext, texCoord, _expressions.ValueTypes.NUMBER_ARRAY);\n  var parsedRotation = (0, _expressions.expressionToGlsl)(vertContext, rotation, _expressions.ValueTypes.NUMBER);\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  var fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap\n  };\n  var parsedColor = (0, _expressions.expressionToGlsl)(fragContext, color, _expressions.ValueTypes.COLOR);\n  var parsedOpacity = (0, _expressions.expressionToGlsl)(fragContext, opacity, _expressions.ValueTypes.NUMBER);\n  var opacityFilter = '1.0';\n  var visibleSize = \"vec2(\" + (0, _expressions.expressionToGlsl)(fragContext, size, _expressions.ValueTypes.NUMBER_ARRAY | _expressions.ValueTypes.NUMBER) + \").x\";\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = \"(1.0-smoothstep(1.-4./\" + visibleSize + \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\";\n      break;\n    case 'triangle':\n      var st = '(v_quadCoord*2.-1.)';\n      var a = \"(atan(\" + st + \".x,\" + st + \".y))\";\n      opacityFilter = \"(1.0-smoothstep(.5-3./\" + visibleSize + \",.5,cos(floor(.5+\" + a + \"/2.094395102)*2.094395102-\" + a + \")*length(\" + st + \")))\";\n      break;\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n  var builder = new ShaderBuilder().setSizeExpression(\"vec2(\" + parsedSize + \")\").setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(\"vec4(\" + parsedColor + \".rgb, \" + parsedColor + \".a * \" + parsedOpacity + \" * \" + opacityFilter + \")\");\n  if (style.filter) {\n    var parsedFilter = (0, _expressions.expressionToGlsl)(fragContext, style.filter, _expressions.ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(\"!\" + parsedFilter);\n  }\n  /** @type {Object.<string,import(\"../webgl/Helper\").UniformValue>} */\n  var uniforms = {};\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    builder.addUniform(\"float u_\" + varName);\n    uniforms[\"u_\" + varName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\"The following variable is missing from the style: \" + varName);\n      }\n      var value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = (0, _expressions.getStringNumberEquivalent)(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    var texture = new Image();\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  }\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(\"v_\" + attrName, 'float', \"a_\" + attrName);\n  });\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(\"float a_\" + attrName);\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          var value = props[attributeName];\n          if (typeof value === 'string') {\n            value = (0, _expressions.getStringNumberEquivalent)(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n    uniforms: uniforms\n  };\n}"},"sourceMaps":null,"error":null,"hash":"5f6cc1e6954eab799a2781b90a22ab04","cacheData":{"env":{}}}