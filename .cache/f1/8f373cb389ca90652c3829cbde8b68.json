{"id":"CreQ","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\package.json","includedInParent":true,"mtime":1749531473813},{"name":"ol/format/GeoJSON.js","loc":{"line":6,"column":20,"index":222},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\format\\GeoJSON.js"},{"name":"ol/format/MVT.js","loc":{"line":7,"column":16,"index":262},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\format\\MVT.js"},{"name":"ol/Map.js","loc":{"line":8,"column":16,"index":298},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\Map.js"},{"name":"ol/tilegrid/TileGrid.js","loc":{"line":9,"column":21,"index":332},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\tilegrid\\TileGrid.js"},{"name":"ol/source/TileJSON.js","loc":{"line":10,"column":21,"index":380},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\TileJSON.js"},{"name":"ol/layer/Tile.js","loc":{"line":11,"column":22,"index":427},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Tile.js"},{"name":"ol/layer/Vector.js","loc":{"line":12,"column":24,"index":471},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\Vector.js"},{"name":"ol/source/Vector.js","loc":{"line":13,"column":25,"index":518},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\Vector.js"},{"name":"ol/layer/VectorTile.js","loc":{"line":14,"column":28,"index":569},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\layer\\VectorTile.js"},{"name":"ol/source/VectorTile.js","loc":{"line":15,"column":29,"index":624},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js"},{"name":"ol/View.js","loc":{"line":16,"column":17,"index":668},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\View.js"},{"name":"./stylefunction.js","loc":{"line":17,"column":65,"index":747},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js"},{"name":"webfont-matcher/lib/fonts/google.js","loc":{"line":18,"column":24,"index":793},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\webfont-matcher\\lib\\fonts\\google.js"},{"name":"mapbox-to-css-font","loc":{"line":19,"column":19,"index":851},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\mapbox-to-css-font\\index.js"},{"name":"@mapbox/mapbox-gl-style-spec","loc":{"line":20,"column":22,"index":895},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\@mapbox\\mapbox-gl-style-spec\\dist\\index.es.js"},{"name":"./util.js","loc":{"line":21,"column":43,"index":970},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\util.js"},{"name":"ol/tilegrid.js","loc":{"line":22,"column":26,"index":1009},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\tilegrid.js"},{"name":"ol/proj.js","loc":{"line":23,"column":27,"index":1054},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\proj.js"},{"name":"ol/obj.js","loc":{"line":24,"column":24,"index":1092},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\obj.js"},{"name":"ol/Observable.js","loc":{"line":25,"column":24,"index":1129},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\index.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\Observable.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._finalizeLayer = finalizeLayer;\nexports._getFonts = getFonts;\nexports.apply = apply;\nexports.applyBackground = applyBackground;\nexports.applyStyle = applyStyle;\nexports.default = olms;\nexports.getLayer = getLayer;\nexports.getLayers = getLayers;\nexports.getSource = getSource;\nexports.setupVectorSource = setupVectorSource;\nvar _GeoJSON = _interopRequireDefault(require(\"ol/format/GeoJSON.js\"));\nvar _MVT = _interopRequireDefault(require(\"ol/format/MVT.js\"));\nvar _Map = _interopRequireDefault(require(\"ol/Map.js\"));\nvar _TileGrid = _interopRequireDefault(require(\"ol/tilegrid/TileGrid.js\"));\nvar _TileJSON = _interopRequireDefault(require(\"ol/source/TileJSON.js\"));\nvar _Tile = _interopRequireDefault(require(\"ol/layer/Tile.js\"));\nvar _Vector = _interopRequireDefault(require(\"ol/layer/Vector.js\"));\nvar _Vector2 = _interopRequireDefault(require(\"ol/source/Vector.js\"));\nvar _VectorTile = _interopRequireDefault(require(\"ol/layer/VectorTile.js\"));\nvar _VectorTile2 = _interopRequireDefault(require(\"ol/source/VectorTile.js\"));\nvar _View = _interopRequireDefault(require(\"ol/View.js\"));\nvar _stylefunction = _interopRequireWildcard(require(\"./stylefunction.js\"));\nvar _google = _interopRequireDefault(require(\"webfont-matcher/lib/fonts/google.js\"));\nvar _mapboxToCssFont = _interopRequireDefault(require(\"mapbox-to-css-font\"));\nvar _mapboxGlStyleSpec = require(\"@mapbox/mapbox-gl-style-spec\");\nvar _util = require(\"./util.js\");\nvar _tilegrid = require(\"ol/tilegrid.js\");\nvar _proj = require(\"ol/proj.js\");\nvar _obj = require(\"ol/obj.js\");\nvar _Observable = require(\"ol/Observable.js\");\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n\n/**\n * @typedef {import(\"ol/Map\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\nvar tilejsonCache = {};\nvar fontFamilyRegEx = /font-family: ?([^;]*);/;\nvar stripQuotesRegEx = /(\"|')/g;\nvar loadedFontFamilies;\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    var styleSheets = document.styleSheets;\n    for (var i = 0, ii = styleSheets.length; i < ii; ++i) {\n      var styleSheet = /** @type {CSSStyleSheet} */styleSheets[i];\n      try {\n        var cssRules = styleSheet.rules || styleSheet.cssRules;\n        if (cssRules) {\n          for (var j = 0, jj = cssRules.length; j < jj; ++j) {\n            var cssRule = cssRules[j];\n            if (cssRule.type == 5) {\n              var match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {\n        // empty catch block\n      }\n    }\n  }\n  return family in loadedFontFamilies;\n}\nvar processedFontFamilies = {};\nvar googleFamilies = _google.default.getNames();\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\nfunction getFonts(fonts) {\n  var fontsKey = fonts.toString();\n  if (fontsKey in processedFontFamilies) {\n    return fonts;\n  }\n  var googleFontDescriptions = fonts.map(function (font) {\n    var parts = (0, _mapboxToCssFont.default)(font, 1).split(' ');\n    return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n  });\n  for (var i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n    var googleFontDescription = googleFontDescriptions[i];\n    var family = googleFontDescription[0];\n    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n      var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];\n      if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n        var markup = document.createElement('link');\n        markup.href = fontUrl;\n        markup.rel = 'stylesheet';\n        document.head.appendChild(markup);\n      }\n    }\n  }\n  processedFontFamilies[fontsKey] = true;\n  return fonts;\n}\nvar spriteRegEx = /^(.*)(\\?.*)$/;\nfunction withPath(url, path) {\n  if (path && url.indexOf('.') === 0) {\n    url = path + url;\n  }\n  return url;\n}\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  var parts = url.match(spriteRegEx);\n  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;\n}\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\nfunction applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function (resolve, reject) {\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    if (typeof glStyle != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n      return reject(new Error('glStyle version 8 required.'));\n    }\n    if (!(layer instanceof _Vector.default || layer instanceof _VectorTile.default)) {\n      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n    }\n    var spriteScale, spriteData, spriteImageUrl, style;\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData)) {\n        style = (0, _stylefunction.default)(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n        if (!layer.getStyle()) {\n          reject(new Error(\"Nothing to show for source [\".concat(source, \"]\")));\n        } else {\n          resolve();\n        }\n      } else if (style) {\n        layer.setStyle(style);\n        resolve();\n      } else {\n        reject(new Error('Something went wrong trying to apply style.'));\n      }\n    }\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      var sizeFactor_1 = spriteScale == 0.5 ? '@2x' : '';\n      var spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.json');\n      fetch(spriteUrl_1, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        if (!response.ok && sizeFactor_1 !== '') {\n          spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, '.json');\n          return fetch(spriteUrl_1, {\n            credentials: 'same-origin'\n          });\n        } else {\n          return response;\n        }\n      }).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          reject(new Error(\"Problem fetching sprite from \".concat(spriteUrl_1, \": \").concat(response.statusText)));\n        }\n      }).then(function (spritesJson) {\n        if (spritesJson === undefined) {\n          return reject(new Error('No sprites found.'));\n        }\n        spriteData = spritesJson;\n        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.png');\n        onChange();\n      }).catch(function (err) {\n        reject(new Error(\"Sprites cannot be loaded: \".concat(spriteUrl_1, \": \").concat(err.message)));\n      });\n    } else {\n      onChange();\n    }\n  });\n}\nvar emptyObj = {};\nfunction setBackground(mapOrLayer, layer) {\n  var background = {\n    id: layer.id,\n    type: layer.type\n  };\n  var functionCache = {};\n  function updateStyle(resolution) {\n    var layout = layer.layout || {};\n    var paint = layer.paint || {};\n    background['paint'] = paint;\n    var zoom = typeof mapOrLayer.getSource === 'function' ? mapOrLayer.getSource().getTileGrid().getZForResolution(resolution) : mapOrLayer.getView().getZoom();\n    var element = typeof mapOrLayer.getTargetElement === 'function' ? mapOrLayer.getTargetElement() : undefined;\n    var bg, opacity;\n    if (paint['background-color'] !== undefined) {\n      bg = (0, _stylefunction.getValue)(background, 'paint', 'background-color', zoom, emptyObj, functionCache);\n      if (element) {\n        element.style.background = _mapboxGlStyleSpec.Color.parse(bg).toString();\n      }\n    }\n    if (paint['background-opacity'] !== undefined) {\n      opacity = (0, _stylefunction.getValue)(background, 'paint', 'background-opacity', zoom, emptyObj, functionCache);\n      if (element) {\n        element.style.opacity = opacity;\n      }\n    }\n    if (layout.visibility == 'none') {\n      if (element) {\n        element.style.backgroundColor = '';\n        element.style.opacity = '';\n      }\n      return undefined;\n    }\n    return (0, _stylefunction._colorWithOpacity)(bg, opacity);\n  }\n  if (typeof mapOrLayer.getTargetElement === 'function') {\n    if (mapOrLayer.getTargetElement()) {\n      updateStyle();\n    }\n    mapOrLayer.on(['change:resolution', 'change:target'], updateStyle);\n  } else if (typeof mapOrLayer.setBackground === 'function') {\n    mapOrLayer.setBackground(updateStyle);\n  } else {\n    throw new Error('Unable to apply background.');\n  }\n}\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the\n * provided map or VectorTile layer.\n * @param {PluggableMap|VectorTileLayer} mapOrLayer OpenLayers Map or VectorTile layer.\n * @param {Object} glStyle Mapbox Style object.\n */\nfunction applyBackground(mapOrLayer, glStyle) {\n  glStyle.layers.some(function (l) {\n    if (l.type == 'background') {\n      setBackground(mapOrLayer, l);\n      return true;\n    }\n  });\n}\nfunction getSourceIdByRef(layers, ref) {\n  var sourceId;\n  layers.some(function (layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\nfunction extentFromTileJSON(tileJSON) {\n  var bounds = tileJSON.bounds;\n  if (bounds) {\n    var ll = (0, _proj.fromLonLat)([bounds[0], bounds[1]]);\n    var tr = (0, _proj.fromLonLat)([bounds[2], bounds[3]]);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n}\n/**\n * Creates an OpenLayers VectorTile source for a gl source entry.\n * @param {Object} glSource \"source\" entry from a Mapbox Style object.\n * @param {string|undefined} url URL to use for the source. This is expected to be the complete http(s) url,\n * with access key applied.When not provided, `glSource.tiles` has to be set.\n * @return {Promise<import(\"ol/source/VectorTile\").default>} Promise resolving to a VectorTile source.\n * @private\n */\nfunction setupVectorSource(glSource, url) {\n  glSource = (0, _util.assign)({}, glSource);\n  var cacheKey = [url, JSON.stringify(glSource)].toString();\n  var tilejson = tilejsonCache[cacheKey];\n  if (!tilejson) {\n    tilejson = new _TileJSON.default({\n      url: glSource.tiles ? undefined : url,\n      tileJSON: glSource.tiles ? glSource : undefined\n    });\n    tilejsonCache[cacheKey] = tilejson;\n  }\n  return new Promise(function (resolve) {\n    var key = tilejson.on('change', function () {\n      var state = tilejson.getState();\n      if (state === 'ready') {\n        var tileJSONDoc = tilejson.getTileJSON();\n        var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n        if (url) {\n          for (var i = 0, ii = tiles.length; i < ii; ++i) {\n            tiles[i] = decodeURI(new URL(tiles[i], url).href);\n          }\n        }\n        var tileGrid = tilejson.getTileGrid();\n        var extent = extentFromTileJSON(tileJSONDoc);\n        var minZoom = tileJSONDoc.minzoom || 0;\n        var maxZoom = tileJSONDoc.maxzoom || 22;\n        var source = tilejson.get('ol-source');\n        if (source === undefined) {\n          source = new _VectorTile2.default({\n            attributions: tilejson.getAttributions(),\n            format: new _MVT.default(),\n            tileGrid: new _TileGrid.default({\n              origin: tileGrid.getOrigin(0),\n              extent: extent || tileGrid.getExtent(),\n              minZoom: minZoom,\n              resolutions: _util.defaultResolutions.slice(0, maxZoom + 1),\n              tileSize: 512\n            }),\n            urls: tiles\n          });\n          tilejson.set('ol-source', source);\n        }\n        (0, _Observable.unByKey)(key);\n        resolve(source);\n      } else if (state === 'error') {\n        tilejson.set('ol-source', null);\n        (0, _Observable.unByKey)(key);\n        resolve(undefined);\n      }\n    });\n    if (tilejson.getState() === 'ready') {\n      tilejson.changed();\n    }\n  });\n}\nfunction setupVectorLayer(glSource, url) {\n  var layer = new _VectorTile.default({\n    declutter: true,\n    visible: false\n  });\n  setupVectorSource(glSource, url).then(function (source) {\n    layer.setSource(source);\n  });\n  return layer;\n}\nfunction setupRasterLayer(glSource, url) {\n  var layer = new _Tile.default();\n  var source = new _TileJSON.default({\n    transition: 0,\n    url: glSource.tiles ? undefined : url,\n    tileJSON: glSource.tiles ? glSource : undefined,\n    crossOrigin: 'anonymous'\n  });\n  var key = source.on('change', function () {\n    var state = source.getState();\n    if (state === 'ready') {\n      (0, _Observable.unByKey)(key);\n      var tileJSONDoc = /** @type {Object} */source.getTileJSON();\n      var extent = extentFromTileJSON(tileJSONDoc);\n      var tileGrid = source.getTileGrid();\n      var tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n      var minZoom = tileJSONDoc.minzoom || 0;\n      var maxZoom = tileJSONDoc.maxzoom || 22;\n      // Only works when using ES modules\n      //@ts-ignore\n      source.tileGrid = new _TileGrid.default({\n        origin: tileGrid.getOrigin(0),\n        extent: extent || tileGrid.getExtent(),\n        minZoom: minZoom,\n        resolutions: (0, _tilegrid.createXYZ)({\n          maxZoom: maxZoom,\n          tileSize: tileSize\n        }).getResolutions(),\n        tileSize: tileSize\n      });\n      layer.setSource(source);\n    } else if (state === 'error') {\n      (0, _Observable.unByKey)(key);\n      layer.setSource(undefined);\n    }\n  });\n  source.setTileLoadFunction(function (tile, src) {\n    if (src.indexOf('{bbox-epsg-3857}') != -1) {\n      var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n      src = src.replace('{bbox-epsg-3857}', bbox.toString());\n    }\n    var img = /** @type {import(\"ol/ImageTile\").default} */tile.getImage();\n    /** @type {HTMLImageElement} */\n    img.src = src;\n  });\n  return layer;\n}\nvar geoJsonFormat = new _GeoJSON.default();\nfunction setupGeoJSONLayer(glSource, path) {\n  var data = glSource.data;\n  var features, geoJsonUrl;\n  if (typeof data == 'string') {\n    geoJsonUrl = withPath(data, path);\n  } else {\n    features = geoJsonFormat.readFeatures(data, {\n      featureProjection: 'EPSG:3857'\n    });\n  }\n  return new _Vector.default({\n    source: new _Vector2.default({\n      attributions: glSource.attribution,\n      features: features,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    }),\n    visible: false\n  });\n}\nfunction updateRasterLayerProperties(glLayer, layer, view, functionCache) {\n  var zoom = view.getZoom();\n  var opacity = (0, _stylefunction.getValue)(glLayer, 'paint', 'raster-opacity', zoom, emptyObj, functionCache);\n  layer.setOpacity(opacity);\n}\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  if (accessToken === void 0) {\n    accessToken = '';\n  }\n  var promises = [];\n  var view = map.getView();\n  if (typeof view.options_ === 'object' ? (0, _obj.isEmpty)(view.options_) : !view.isDef() && !view.getRotation() && !view.getResolutions()) {\n    view = new _View.default((0, _util.assign)(view.getProperties(), {\n      maxResolution: _util.defaultResolutions[0]\n    }));\n    map.setView(view);\n  }\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter((0, _proj.fromLonLat)(glStyle.center));\n  }\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setResolution(_util.defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n  }\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;\n    }\n  }\n  var glLayers = glStyle.layers;\n  var layerIds = [];\n  var glLayer, glSource, glSourceId, id, layer, url;\n  var _loop_1 = function (i, ii) {\n    glLayer = glLayers[i];\n    var type = glLayer.type;\n    if (type == 'heatmap' || type == 'hillshade') {\n      //FIXME Unsupported layer type\n    } else if (type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n      // this technique assumes gl layers will be in a particular order\n      if (id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n          layerIds = [];\n        }\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n        if (url) {\n          url = withPath(url, path);\n          if (url.indexOf('mapbox://') == 0) {\n            var mapid_1 = url.replace('mapbox://', '');\n            glSource.tiles = ['a', 'b', 'c', 'd'].map(function (host) {\n              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid_1 + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;\n            });\n          } else if (url.indexOf('/') === 0 && host.indexOf('http') === 0) {\n            url = host + url;\n          }\n        }\n        if (glSource.tiles) {\n          glSource.tiles = glSource.tiles.map(function (url) {\n            return withPath(url, path);\n          });\n        }\n        if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, url);\n        } else if (glSource.type == 'raster') {\n          layer = setupRasterLayer(glSource, url);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          var functionCache = {};\n          view.on('change:resolution', updateRasterLayerProperties.bind(this_1, glLayer, layer, view, functionCache));\n          updateRasterLayerProperties(glLayer, layer, view, functionCache);\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, path);\n        }\n        glSourceId = id;\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n      layerIds.push(glLayer.id);\n    }\n  };\n  var this_1 = this;\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    _loop_1(i, ii);\n  }\n  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n  map.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\nfunction olms(map, style) {\n  var promise,\n    accessToken = '',\n    baseUrl = '',\n    host = '',\n    path = '';\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new _Map.default({\n      target: map\n    });\n  }\n  if (typeof style === 'string') {\n    var parts = style.match(spriteRegEx);\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n    promise = new Promise(function (resolve, reject) {\n      fetch(style, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        return response.json();\n      }).then(function (glStyle) {\n        var a = /** @type {HTMLAnchorElement} */document.createElement('A');\n        a.href = style;\n        var href = a.href;\n        path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n        host = href.substr(0, href.indexOf(path));\n        processStyle(glStyle, map, baseUrl, host, path, accessToken).then(function () {\n          resolve(map);\n        }).catch(reject);\n      }).catch(function (err) {\n        reject(new Error(\"Could not load \".concat(style, \": \").concat(err.message)));\n      });\n    });\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      processStyle(style, map).then(function () {\n        resolve(map);\n      }).catch(reject);\n    });\n  }\n  return promise;\n}\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\nfunction apply(map, style) {\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new _Map.default({\n      target: map\n    });\n  }\n  setTimeout(function () {\n    olms(map, style);\n  }, 0);\n  return map;\n}\n/**\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n * @private\n */\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n  var minZoom = 24;\n  var maxZoom = 0;\n  var glLayers = glStyle.layers;\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    var glLayer = glLayers[i];\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n  return new Promise(function (resolve, reject) {\n    var setStyle = function () {\n      var source = layer.getSource();\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n      if (typeof source.getTileGrid === 'function') {\n        var tileGrid = source.getTileGrid();\n        if (tileGrid) {\n          var sourceMinZoom = tileGrid.getMinZoom();\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(_util.defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n          if (maxZoom < 24) {\n            layer.setMinResolution(_util.defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      }\n      if (source instanceof _Vector2.default || source instanceof _VectorTile2.default) {\n        applyStyle(/** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */layer, glStyle, layerIds, path).then(function () {\n          layer.setVisible(true);\n          resolve();\n        }, function (e) {\n          reject(e);\n        });\n      } else {\n        resolve();\n      }\n    };\n    layer.set('mapbox-layers', layerIds);\n    if (map.getLayers().getArray().indexOf(layer) === -1) {\n      map.addLayer(layer);\n    }\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\nfunction getLayer(map, layerId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var mapboxLayers = layers[i].get('mapbox-layers');\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return /** @type {Layer} */layers[i];\n    }\n  }\n}\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\nfunction getLayers(map, sourceId) {\n  var result = [];\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push(/** @type {Layer} */layers[i]);\n    }\n  }\n  return result;\n}\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\nfunction getSource(map, sourceId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var source = /** @type {Layer} */layers[i].getSource();\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}"},"sourceMaps":null,"error":null,"hash":"3f9abc916e20407508789c0c09b733bb","cacheData":{"env":{}}}