{"id":"WlOd","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"./common.js","loc":{"line":17,"column":32,"index":652},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\common.js"},{"name":"../events/EventType.js","loc":{"line":18,"column":22,"index":689},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\EventType.js"},{"name":"../Tile.js","loc":{"line":19,"column":17,"index":732},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\Tile.js"},{"name":"../TileState.js","loc":{"line":20,"column":22,"index":768},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\TileState.js"},{"name":"./Triangulation.js","loc":{"line":21,"column":26,"index":813},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Triangulation.js"},{"name":"../reproj.js","loc":{"line":22,"column":78,"index":913},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj.js"},{"name":"../math.js","loc":{"line":23,"column":22,"index":951},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\math.js"},{"name":"../extent.js","loc":{"line":24,"column":41,"index":1006},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../events.js","loc":{"line":25,"column":38,"index":1060},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\reproj\\Tile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _common = require(\"./common.js\");\nvar _EventType = _interopRequireDefault(require(\"../events/EventType.js\"));\nvar _Tile = _interopRequireDefault(require(\"../Tile.js\"));\nvar _TileState = _interopRequireDefault(require(\"../TileState.js\"));\nvar _Triangulation = _interopRequireDefault(require(\"./Triangulation.js\"));\nvar _reproj = require(\"../reproj.js\");\nvar _math = require(\"../math.js\");\nvar _extent = require(\"../extent.js\");\nvar _events = require(\"../events.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */function (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   * @param {object=} opt_contextOptions Properties to set on the canvas context.\n   */\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n    var _this = _super.call(this, tileCoord, _TileState.default.IDLE) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {object}\n     */\n    _this.contextOptions_ = opt_contextOptions;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;\n    if ((0, _extent.getArea)(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = _TileState.default.EMPTY;\n      return _this;\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = (0, _reproj.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = _TileState.default.EMPTY;\n      return _this;\n    }\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common.ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = _TileState.default.EMPTY;\n      return _this;\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!(0, _extent.getArea)(sourceExtent)) {\n      _this.state = _TileState.default.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = _TileState.default.EMPTY;\n      }\n    }\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == _TileState.default.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = _TileState.default.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = (0, _reproj.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n      this.state = _TileState.default.LOADED;\n    }\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n  ReprojTile.prototype.load = function () {\n    if (this.state == _TileState.default.IDLE) {\n      this.state = _TileState.default.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == _TileState.default.IDLE || state == _TileState.default.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = (0, _events.listen)(tile, _EventType.default.CHANGE, function (e) {\n            var state = tile.getState();\n            if (state == _TileState.default.LOADED || state == _TileState.default.ERROR || state == _TileState.default.EMPTY) {\n              (0, _events.unlistenByKey)(sourceListenKey_1);\n              leftToLoad_1--;\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == _TileState.default.IDLE) {\n          tile.load();\n        }\n      });\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(_events.unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  return ReprojTile;\n}(_Tile.default);\nvar _default = exports.default = ReprojTile;"},"sourceMaps":null,"error":null,"hash":"24dadf321a0a082e2e4d1625721ebaaf","cacheData":{"env":{}}}