{"id":"A6uo","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"../events/EventType.js","loc":{"line":17,"column":22,"index":648},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\events\\EventType.js"},{"name":"../VectorTile.js","loc":{"line":18,"column":17,"index":691},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\VectorTile.js"},{"name":"../TileCache.js","loc":{"line":19,"column":22,"index":733},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\TileCache.js"},{"name":"../TileState.js","loc":{"line":20,"column":22,"index":774},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\TileState.js"},{"name":"./UrlTile.js","loc":{"line":21,"column":20,"index":813},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\UrlTile.js"},{"name":"../VectorRenderTile.js","loc":{"line":22,"column":29,"index":858},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\VectorRenderTile.js"},{"name":"../extent.js","loc":{"line":23,"column":69,"index":953},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../tilegrid.js","loc":{"line":24,"column":70,"index":1039},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\tilegrid.js"},{"name":"../array.js","loc":{"line":25,"column":23,"index":1080},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\array.js"},{"name":"../tilecoord.js","loc":{"line":26,"column":35,"index":1130},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\tilecoord.js"},{"name":"../featureloader.js","loc":{"line":27,"column":32,"index":1181},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\featureloader.js"},{"name":"../size.js","loc":{"line":28,"column":23,"index":1227},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\source\\VectorTile.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\size.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.defaultLoadFunction = defaultLoadFunction;\nvar _EventType = _interopRequireDefault(require(\"../events/EventType.js\"));\nvar _VectorTile = _interopRequireDefault(require(\"../VectorTile.js\"));\nvar _TileCache = _interopRequireDefault(require(\"../TileCache.js\"));\nvar _TileState = _interopRequireDefault(require(\"../TileState.js\"));\nvar _UrlTile = _interopRequireDefault(require(\"./UrlTile.js\"));\nvar _VectorRenderTile = _interopRequireDefault(require(\"../VectorRenderTile.js\"));\nvar _extent = require(\"../extent.js\");\nvar _tilegrid = require(\"../tilegrid.js\");\nvar _array = require(\"../array.js\");\nvar _tilecoord = require(\"../tilecoord.js\");\nvar _featureloader = require(\"../featureloader.js\");\nvar _size = require(\"../size.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * @module ol/source/VectorTile\n */\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */function (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  function VectorTile(options) {\n    var _this = this;\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || (0, _tilegrid.extentFromProjection)(projection);\n    var tileGrid = options.tileGrid || (0, _tilegrid.createXYZ)({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @type {Object<string, import(\"./VectorTile\").default>}\n     */\n    _this.loadingTiles_ = {};\n    /**\n     * @private\n     * @type {TileCache}\n     */\n    _this.sourceTileCache = new _TileCache.default(_this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    _this.tileClass = options.tileClass ? options.tileClass : _VectorTile.default;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  VectorTile.prototype.getFeaturesInExtent = function (extent) {\n    var features = [];\n    var tileCache = this.tileCache;\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    var z = (0, _tilecoord.fromKey)(tileCache.peekFirstKey())[0];\n    var tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== _TileState.default.LOADED) {\n        return;\n      }\n      var sourceTiles = tile.getSourceTiles();\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        var tileCoord = sourceTile.tileCoord;\n        if ((0, _extent.intersects)(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          var tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              var candidate = tileFeatures[j];\n              var geometry = candidate.getGeometry();\n              if ((0, _extent.intersects)(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  VectorTile.prototype.expireCache = function (projection, usedTiles) {\n    _super.prototype.expireCache.call(this, projection, usedTiles);\n    this.sourceTileCache.expireCache({});\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var urlTileCoord = tile.wrappedTileCoord;\n    var tileGrid = this.getTileGridForProjection(projection);\n    var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n    var z = urlTileCoord[0];\n    var resolution = tileGrid.getResolution(z);\n    // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n    (0, _extent.buffer)(extent, -resolution, extent);\n    var sourceTileGrid = this.tileGrid;\n    var sourceExtent = sourceTileGrid.getExtent();\n    if (sourceExtent) {\n      (0, _extent.getIntersection)(extent, sourceExtent, extent);\n    }\n    var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n    var minZoom = sourceTileGrid.getMinZoom();\n    var previousSourceTiles = tile.sourceTiles;\n    var sourceTiles, covered, loadedZ;\n    if (previousSourceTiles && previousSourceTiles.length > 0 && previousSourceTiles[0].tileCoord[0] === sourceZ) {\n      sourceTiles = previousSourceTiles;\n      covered = true;\n      loadedZ = sourceZ;\n    } else {\n      sourceTiles = [];\n      loadedZ = sourceZ + 1;\n      do {\n        --loadedZ;\n        covered = true;\n        sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n          var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n          var sourceTile;\n          if (tileUrl !== undefined) {\n            if (this.sourceTileCache.containsKey(tileUrl)) {\n              sourceTile = this.sourceTileCache.get(tileUrl);\n              var state = sourceTile.getState();\n              if (state === _TileState.default.LOADED || state === _TileState.default.ERROR || state === _TileState.default.EMPTY) {\n                sourceTiles.push(sourceTile);\n                return;\n              }\n            } else if (loadedZ === sourceZ) {\n              sourceTile = new this.tileClass(sourceTileCoord, _TileState.default.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n              sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n              sourceTile.projection = projection;\n              sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n              this.sourceTileCache.set(tileUrl, sourceTile);\n              sourceTile.addEventListener(_EventType.default.CHANGE, this.handleTileChange.bind(this));\n              sourceTile.load();\n            }\n          }\n          covered = covered && sourceTile && sourceTile.getState() === _TileState.default.LOADED;\n          if (!sourceTile) {\n            return;\n          }\n          if (sourceTile.getState() !== _TileState.default.EMPTY && tile.getState() === _TileState.default.IDLE) {\n            tile.loadingSourceTiles++;\n            sourceTile.addEventListener(_EventType.default.CHANGE, function listenChange() {\n              var state = sourceTile.getState();\n              var sourceTileKey = sourceTile.getKey();\n              if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {\n                if (state === _TileState.default.LOADED) {\n                  sourceTile.removeEventListener(_EventType.default.CHANGE, listenChange);\n                  tile.loadingSourceTiles--;\n                  delete tile.errorSourceTileKeys[sourceTileKey];\n                } else if (state === _TileState.default.ERROR) {\n                  tile.errorSourceTileKeys[sourceTileKey] = true;\n                }\n                var errorTileCount = Object.keys(tile.errorSourceTileKeys).length;\n                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                  tile.hifi = errorTileCount === 0;\n                  tile.sourceZ = sourceZ;\n                  tile.setState(_TileState.default.LOADED);\n                }\n              }\n            });\n          }\n        }.bind(this));\n        if (!covered) {\n          sourceTiles.length = 0;\n        }\n      } while (!covered && loadedZ > minZoom);\n    }\n    if (tile.getState() === _TileState.default.IDLE) {\n      tile.setState(_TileState.default.LOADING);\n    }\n    if (covered) {\n      tile.hifi = sourceZ === loadedZ;\n      tile.sourceZ = loadedZ;\n      if (tile.getState() < _TileState.default.LOADED) {\n        tile.setState(_TileState.default.LOADED);\n      } else if (!previousSourceTiles || !(0, _array.equals)(sourceTiles, previousSourceTiles)) {\n        tile.sourceTiles = sourceTiles;\n      }\n    }\n    return sourceTiles;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = (0, _tilecoord.getKeyZXY)(z, x, y);\n    var key = this.getKey();\n    var tile;\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      (0, _extent.buffer)(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!(0, _extent.intersects)(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    var empty = true;\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      (0, _extent.buffer)(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n    var newTile = new _VectorRenderTile.default(tileCoord, empty ? _TileState.default.EMPTY : _TileState.default.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n    return newTile;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = (0, _tilegrid.createForProjection)(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  };\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n  };\n  return VectorTile;\n}(_UrlTile.default);\nvar _default = exports.default = VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nfunction defaultLoadFunction(tile, url) {\n  var loader = (0, _featureloader.loadFeaturesXhr)(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  tile.setLoader(loader);\n}"},"sourceMaps":null,"error":null,"hash":"f8cf8701592b063048ba10bf54b874d7","cacheData":{"env":{}}}