{"id":"DEzw","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\package.json","includedInParent":true,"mtime":1749531474589},{"name":"./Builder.js","loc":{"line":17,"column":26,"index":660},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Builder.js"},{"name":"./Instruction.js","loc":{"line":18,"column":30,"index":706},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\Instruction.js"},{"name":"../../geom/GeometryType.js","loc":{"line":19,"column":25,"index":751},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\GeometryType.js"},{"name":"../../style/TextPlacement.js","loc":{"line":20,"column":26,"index":807},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\TextPlacement.js"},{"name":"../../colorlike.js","loc":{"line":21,"column":28,"index":867},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\colorlike.js"},{"name":"../canvas.js","loc":{"line":22,"column":246,"index":1135},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas.js"},{"name":"../../util.js","loc":{"line":23,"column":23,"index":1174},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\util.js"},{"name":"../../extent.js","loc":{"line":24,"column":27,"index":1218},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\extent.js"},{"name":"../../geom/flat/straightchunk.js","loc":{"line":25,"column":30,"index":1267},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\canvas\\TextBuilder.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\geom\\flat\\straightchunk.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.TEXT_ALIGN = void 0;\nvar _Builder = _interopRequireDefault(require(\"./Builder.js\"));\nvar _Instruction = _interopRequireDefault(require(\"./Instruction.js\"));\nvar _GeometryType = _interopRequireDefault(require(\"../../geom/GeometryType.js\"));\nvar _TextPlacement = _interopRequireDefault(require(\"../../style/TextPlacement.js\"));\nvar _colorlike = require(\"../../colorlike.js\");\nvar _canvas = require(\"../canvas.js\");\nvar _util = require(\"../../util.js\");\nvar _extent = require(\"../../extent.js\");\nvar _straightchunk = require(\"../../geom/flat/straightchunk.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/TextBuilder\n */\n\n/**\n * @const\n * @enum {number}\n */\nvar TEXT_ALIGN = exports.TEXT_ALIGN = {\n  'left': 0,\n  'end': 0,\n  'center': 0.5,\n  'right': 1,\n  'start': 1,\n  'top': 0,\n  'middle': 0.5,\n  'hanging': 0.2,\n  'alphabetic': 0.8,\n  'ideographic': 0.8,\n  'bottom': 1\n};\nvar CanvasTextBuilder = /** @class */function (_super) {\n  __extends(CanvasTextBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterGroups}\n     */\n    _this.declutterGroups_;\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    _this.labels_ = null;\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.text_ = '';\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textOffsetX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textOffsetY_ = 0;\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    _this.textRotateWithView_ = undefined;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textRotation_ = 0;\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    _this.textFillState_ = null;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    _this.fillStates = {};\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    _this.textStrokeState_ = null;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    _this.strokeStates = {};\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    _this.textState_ = /** @type {import(\"../canvas.js\").TextState} */{};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    _this.textStates = {};\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.textKey_ = '';\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.fillKey_ = '';\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.strokeKey_ = '';\n    return _this;\n  }\n  /**\n   * @return {import(\"./Builder.js\").SerializableInstructions} the serializable instructions.\n   */\n  CanvasTextBuilder.prototype.finish = function () {\n    var instructions = _super.prototype.finish.call(this);\n    instructions.textStates = this.textStates;\n    instructions.fillStates = this.fillStates;\n    instructions.strokeStates = this.strokeStates;\n    return instructions;\n  };\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasTextBuilder.prototype.drawText = function (geometry, feature) {\n    var fillState = this.textFillState_;\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    if (this.text_ === '' || !textState || !fillState && !strokeState) {\n      return;\n    }\n    var begin = this.coordinates.length;\n    var geometryType = geometry.getType();\n    var flatCoordinates = null;\n    var end = 2;\n    var stride = geometry.getStride();\n    var i, ii;\n    if (textState.placement === _TextPlacement.default.LINE) {\n      if (!(0, _extent.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      var ends = void 0;\n      flatCoordinates = geometry.getFlatCoordinates();\n      if (geometryType == _GeometryType.default.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == _GeometryType.default.MULTI_LINE_STRING) {\n        ends = /** @type {import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds();\n      } else if (geometryType == _GeometryType.default.POLYGON) {\n        ends = /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getEnds().slice(0, 1);\n      } else if (geometryType == _GeometryType.default.MULTI_POLYGON) {\n        var endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getEndss();\n        ends = [];\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      var textAlign = textState.textAlign;\n      var flatOffset = 0;\n      var flatEnd = void 0;\n      for (var o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          var range = (0, _straightchunk.matchingChunk)(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        var declutterGroup = this.declutterGroups_ ? o === 0 ? this.declutterGroups_[0] : [].concat(this.declutterGroups_[0]) : null;\n        this.drawChars_(begin, end, declutterGroup);\n        begin = end;\n      }\n      this.endGeometry(feature);\n    } else {\n      var geometryWidths = null;\n      if (!textState.overflow) {\n        geometryWidths = [];\n      }\n      switch (geometryType) {\n        case _GeometryType.default.POINT:\n        case _GeometryType.default.MULTI_POINT:\n          flatCoordinates = /** @type {import(\"../../geom/MultiPoint.js\").default} */geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n        case _GeometryType.default.LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/LineString.js\").default} */geometry.getFlatMidpoint();\n          break;\n        case _GeometryType.default.CIRCLE:\n          flatCoordinates = /** @type {import(\"../../geom/Circle.js\").default} */geometry.getCenter();\n          break;\n        case _GeometryType.default.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/MultiLineString.js\").default} */geometry.getFlatMidpoints();\n          stride = 2;\n          end = flatCoordinates.length;\n          break;\n        case _GeometryType.default.POLYGON:\n          flatCoordinates = /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getFlatInteriorPoint();\n          if (!textState.overflow) {\n            geometryWidths.push(flatCoordinates[2] / this.resolution);\n          }\n          stride = 3;\n          break;\n        case _GeometryType.default.MULTI_POLYGON:\n          var interiorPoints = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (!textState.overflow) {\n              geometryWidths.push(interiorPoints[i + 2] / this.resolution);\n            }\n            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n          }\n          stride = 2;\n          end = flatCoordinates.length;\n          if (end == 0) {\n            return;\n          }\n          break;\n        default:\n      }\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n      this.saveTextStates_();\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill);\n          this.hitDetectionInstructions.push(this.createFill(this.state));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      // adjust padding for negative scale\n      var padding = textState.padding;\n      if (padding != _canvas.defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {\n        var p0 = textState.padding[0];\n        var p1 = textState.padding[1];\n        var p2 = textState.padding[2];\n        var p3 = textState.padding[3];\n        if (textState.scale[0] < 0) {\n          p1 = -p1;\n          p3 = -p3;\n        }\n        if (textState.scale[1] < 0) {\n          p0 = -p0;\n          p2 = -p2;\n        }\n        padding = [p0, p1, p2, p3];\n      }\n      // The image is unknown at this stage so we pass null; it will be computed at render time.\n      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at\n      // render time.\n      var pixelRatio_1 = this.pixelRatio;\n      this.instructions.push([_Instruction.default.DRAW_IMAGE, begin, end, null, NaN, NaN, this.declutterGroups_, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, padding == _canvas.defaultPadding ? _canvas.defaultPadding : padding.map(function (p) {\n        return p * pixelRatio_1;\n      }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n      var scale = 1 / pixelRatio_1;\n      this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, begin, end, null, NaN, NaN, this.declutterGroups_, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n      this.endGeometry(feature);\n    }\n  };\n  /**\n   * @private\n   */\n  CanvasTextBuilder.prototype.saveTextStates_ = function () {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var fillState = this.textFillState_;\n    var strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n    var textKey = this.textKey_;\n    if (!(textKey in this.textStates)) {\n      this.textStates[textKey] = {\n        font: textState.font,\n        textAlign: textState.textAlign || _canvas.defaultTextAlign,\n        textBaseline: textState.textBaseline || _canvas.defaultTextBaseline,\n        scale: textState.scale\n      };\n    }\n    var fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = {\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   */\n  CanvasTextBuilder.prototype.drawChars_ = function (begin, end, declutterGroup) {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var strokeKey = this.strokeKey_;\n    var textKey = this.textKey_;\n    var fillKey = this.fillKey_;\n    this.saveTextStates_();\n    var pixelRatio = this.pixelRatio;\n    var baseline = TEXT_ALIGN[textState.textBaseline];\n    var offsetY = this.textOffsetY_ * pixelRatio;\n    var text = this.text_;\n    var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;\n    this.instructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n    this.hitDetectionInstructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n  };\n  /**\n   * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n   * @param {import(\"../canvas.js\").DeclutterGroups} declutterGroups Declutter.\n   */\n  CanvasTextBuilder.prototype.setTextStyle = function (textStyle, declutterGroups) {\n    var textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      this.declutterGroups_ = declutterGroups;\n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = null;\n        this.textFillState_ = fillState;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = /** @type {import(\"../canvas.js\").FillState} */{};\n          this.textFillState_ = fillState;\n        }\n        fillState.fillStyle = (0, _colorlike.asColorLike)(textFillStyle.getColor() || _canvas.defaultFillStyle);\n      }\n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = null;\n        this.textStrokeState_ = strokeState;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = /** @type {import(\"../canvas.js\").StrokeState} */{};\n          this.textStrokeState_ = strokeState;\n        }\n        var lineDash = textStrokeStyle.getLineDash();\n        var lineDashOffset = textStrokeStyle.getLineDashOffset();\n        var lineWidth = textStrokeStyle.getWidth();\n        var miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas.defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas.defaultLineDash;\n        strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas.defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas.defaultLineJoin;\n        strokeState.lineWidth = lineWidth === undefined ? _canvas.defaultLineWidth : lineWidth;\n        strokeState.miterLimit = miterLimit === undefined ? _canvas.defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = (0, _colorlike.asColorLike)(textStrokeStyle.getColor() || _canvas.defaultStrokeStyle);\n      }\n      textState = this.textState_;\n      var font = textStyle.getFont() || _canvas.defaultFont;\n      (0, _canvas.registerFont)(font);\n      var textScale = textStyle.getScaleArray();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || _canvas.defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || _canvas.defaultPadding;\n      textState.scale = textScale === undefined ? [1, 1] : textScale;\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0, _util.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.textBaseline || '?');\n      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0, _util.getUid)(fillState.fillStyle) : '';\n    }\n  };\n  return CanvasTextBuilder;\n}(_Builder.default);\nvar _default = exports.default = CanvasTextBuilder;"},"sourceMaps":null,"error":null,"hash":"a904f6e3e73166d7bd7d6fcdcf52bf96","cacheData":{"env":{}}}