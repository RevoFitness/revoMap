{"id":"Fj7k","dependencies":[{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\package.json","includedInParent":true,"mtime":1750141916701},{"name":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\package.json","includedInParent":true,"mtime":1749531473813},{"name":"ol/style/Circle.js","loc":{"line":6,"column":19,"index":221},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Circle.js"},{"name":"ol/style/Fill.js","loc":{"line":7,"column":17,"index":260},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Fill.js"},{"name":"ol/style/Icon.js","loc":{"line":8,"column":17,"index":297},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Icon.js"},{"name":"ol/render/Feature.js","loc":{"line":9,"column":26,"index":343},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\render\\Feature.js"},{"name":"ol/style/Stroke.js","loc":{"line":10,"column":19,"index":386},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Stroke.js"},{"name":"ol/style/Style.js","loc":{"line":11,"column":18,"index":426},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Style.js"},{"name":"ol/style/Text.js","loc":{"line":12,"column":17,"index":464},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol\\style\\Text.js"},{"name":"mapbox-to-css-font","loc":{"line":13,"column":19,"index":503},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\mapbox-to-css-font\\index.js"},{"name":"@mapbox/mapbox-gl-style-spec","loc":{"line":14,"column":111,"index":636},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\@mapbox\\mapbox-gl-style-spec\\dist\\index.es.js"},{"name":"./util.js","loc":{"line":15,"column":111,"index":779},"parent":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\stylefunction.js","resolved":"C:\\Users\\MathewBowyer\\Downloads\\open_layers_map-main\\node_modules\\ol-mapbox-style\\dist\\util.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._colorWithOpacity = colorWithOpacity;\nexports._evaluateFilter = evaluateFilter;\nexports._fromTemplate = fromTemplate;\nexports.default = _default;\nexports._getValue = exports.getValue = getValue;\nexports.recordStyleLayer = recordStyleLayer;\nexports.renderTransparent = renderTransparent;\nvar _Circle = _interopRequireDefault(require(\"ol/style/Circle.js\"));\nvar _Fill = _interopRequireDefault(require(\"ol/style/Fill.js\"));\nvar _Icon = _interopRequireDefault(require(\"ol/style/Icon.js\"));\nvar _Feature = _interopRequireDefault(require(\"ol/render/Feature.js\"));\nvar _Stroke = _interopRequireDefault(require(\"ol/style/Stroke.js\"));\nvar _Style = _interopRequireDefault(require(\"ol/style/Style.js\"));\nvar _Text = _interopRequireDefault(require(\"ol/style/Text.js\"));\nvar _mapboxToCssFont = _interopRequireDefault(require(\"mapbox-to-css-font\"));\nvar _mapboxGlStyleSpec = require(\"@mapbox/mapbox-gl-style-spec\");\nvar _util = require(\"./util.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\nvar isFunction = _mapboxGlStyleSpec.function.isFunction;\nvar convertFunction = _mapboxGlStyleSpec.function.convertFunction;\nvar isExpression = _mapboxGlStyleSpec.expression.isExpression;\nvar createPropertyExpression = _mapboxGlStyleSpec.expression.createPropertyExpression;\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nvar anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\nvar expressionData = function (rawExpression, propertySpec) {\n  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(function (err) {\n      return \"\".concat(err.key, \": \").concat(err.message);\n    }).join(', '));\n  }\n  return compiledExpression.value;\n};\nvar emptyObj = {};\nvar zoomObj = {\n  zoom: 0\n};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @param {Object} [functionCache] Function cache.\n * @return {?} Value.\n */\nfunction getValue(layer, layoutOrPaint, property, zoom, feature, functionCache) {\n  var layerId = layer.id;\n  if (!functionCache) {\n    functionCache = {};\n    console.warn('No functionCache provided to getValue()'); //eslint-disable-line no-console\n  }\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n  var functions = functionCache[layerId];\n  if (!functions[property]) {\n    var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n    var propertySpec = _mapboxGlStyleSpec.latest[\"\".concat(layoutOrPaint, \"_\").concat(layer.type)][property];\n    if (value_1 === undefined) {\n      value_1 = propertySpec.default;\n    }\n    var isExpr = isExpression(value_1);\n    if (!isExpr && isFunction(value_1)) {\n      value_1 = convertFunction(value_1, propertySpec);\n      isExpr = true;\n    }\n    if (isExpr) {\n      var compiledExpression = expressionData(value_1, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value_1 = _mapboxGlStyleSpec.Color.parse(value_1);\n      }\n      functions[property] = function () {\n        return value_1;\n      };\n    }\n  }\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @param {Object} [filterCache] Filter cache.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom, filterCache) {\n  if (!filterCache) {\n    console.warn('No filterCache provided to evaluateFilter()'); //eslint-disable-line no-console\n  }\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = (0, _mapboxGlStyleSpec.featureFilter)(filter).filter;\n  }\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\nvar renderTransparentEnabled = false;\n/**\n * ```js\n * import {renderTransparent} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Configure whether features with a transparent style should be rendered. When\n * set to `true`, it will be possible to hit detect content that is not visible,\n * like transparent fills of polygons, using `ol/layer/Layer#getFeatures()` or\n * `ol/Map#getFeaturesAtPixel()`\n * @param {boolean} enabled Rendering of transparent elements is enabled.\n * Default is `false`.\n */\nfunction renderTransparent(enabled) {\n  renderTransparentEnabled = enabled;\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (!renderTransparentEnabled && (color.a === 0 || opacity === 0)) {\n      return undefined;\n    }\n    var a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return a === 0 ? 'transparent' : 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n  return color;\n}\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n  var parts;\n  do {\n    parts = text.match(templateRegEx);\n    if (parts) {\n      var value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n  return text;\n}\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\nfunction recordStyleLayer(record) {\n  recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {string} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nfunction _default(olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n  if (resolutions === void 0) {\n    resolutions = _util.defaultResolutions;\n  }\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n  var spriteImage, spriteImgSize;\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      var img_1 = new Image();\n      img_1.crossOrigin = 'anonymous';\n      img_1.onload = function () {\n        spriteImage = img_1;\n        spriteImgSize = [img_1.width, img_1.height];\n        olLayer.changed();\n        img_1.onload = null;\n      };\n      img_1.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      //eslint-disable-line\n      var worker = /** @type {*} */self;\n      // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImgSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n  var allLayers = (0, _mapboxGlStyleSpec.derefLayers)(glStyle.layers);\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var iconImageCache = {};\n  var patternCache = {};\n  var functionCache = {};\n  var filterCache = {};\n  var mapboxSource;\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        var source_1 = glStyle.sources[mapboxSource];\n        if (!source_1) {\n          throw new Error(\"Source \\\"\".concat(mapboxSource, \"\\\" is not defined\"));\n        }\n        var type = source_1.type;\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(\"Source \\\"\".concat(mapboxSource, \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\").concat(type, \"\\\"\"));\n        }\n      }\n      var layers = layersBySourceLayer[sourceLayer];\n      if (!layers) {\n        layers = [];\n        layersBySourceLayer[sourceLayer] = layers;\n      }\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    }\n  }\n  var textHalo = new _Stroke.default();\n  var textColor = new _Fill.default();\n  var styles = [];\n  var styleFunction = function (feature, resolution) {\n    var properties = feature.getProperties();\n    var layers = layersBySourceLayer[properties.layer];\n    if (!layers) {\n      return;\n    }\n    var zoom = resolutions.indexOf(resolution);\n    if (zoom == -1) {\n      zoom = (0, _util.getZoomForResolution)(resolution, resolutions);\n    }\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var stylesLength = -1;\n    var featureBelongsToLayer;\n    var _loop_1 = function (i, ii) {\n      var layerData = layers[i];\n      var layer = layerData.layer;\n      var layerId = layer.id;\n      var layout = layer.layout || emptyObj;\n      var paint = layer.paint || emptyObj;\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        return \"continue\";\n      }\n      var filter = layer.filter;\n      if (!filter || evaluateFilter(layerId, filter, f, zoom, filterCache)) {\n        featureBelongsToLayer = layer;\n        var color = void 0,\n          opacity = void 0,\n          fill = void 0,\n          stroke = void 0,\n          strokeColor = void 0,\n          style = void 0;\n        var index = layerData.index;\n        if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n          opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f, functionCache);\n          if (layer.type + '-pattern' in paint) {\n            var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f, functionCache);\n            if (fillIcon) {\n              var icon_1 = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n              if (spriteImage && spriteData && spriteData[icon_1]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = new _Style.default({\n                    fill: new _Fill.default()\n                  });\n                  styles[stylesLength] = style;\n                }\n                fill = style.getFill();\n                style.setZIndex(index);\n                var icon_cache_key = icon_1 + '.' + opacity;\n                var pattern = patternCache[icon_cache_key];\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon_1];\n                  var canvas = (0, _util.createCanvas)(spriteImageData.width, spriteImageData.height);\n                  var ctx = /** @type {CanvasRenderingContext2D} */canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f, functionCache), opacity);\n            if (layer.type + '-outline-color' in paint) {\n              strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f, functionCache), opacity);\n            }\n            if (!strokeColor) {\n              strokeColor = color;\n            }\n            if (color || strokeColor) {\n              ++stylesLength;\n              style = styles[stylesLength];\n              if (!style || color && !style.getFill() || !color && style.getFill() || strokeColor && !style.getStroke() || !strokeColor && style.getStroke() || style.getText()) {\n                style = new _Style.default({\n                  fill: color ? new _Fill.default() : undefined,\n                  stroke: strokeColor ? new _Stroke.default() : undefined\n                });\n                styles[stylesLength] = style;\n              }\n              if (color) {\n                fill = style.getFill();\n                fill.setColor(color);\n              }\n              if (strokeColor) {\n                stroke = style.getStroke();\n                stroke.setColor(strokeColor);\n                stroke.setWidth(0.5);\n              }\n              style.setZIndex(index);\n            }\n          }\n        }\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f, functionCache), getValue(layer, 'paint', 'line-opacity', zoom, f, functionCache)) : undefined;\n          var width_1 = getValue(layer, 'paint', 'line-width', zoom, f, functionCache);\n          if (color && width_1 > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = new _Style.default({\n                stroke: new _Stroke.default()\n              });\n              styles[stylesLength] = style;\n            }\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f, functionCache));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f, functionCache));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f, functionCache));\n            stroke.setColor(color);\n            stroke.setWidth(width_1);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f, functionCache).map(function (x) {\n              return x * width_1;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n        var hasImage = false;\n        var text = null;\n        var placementAngle = 0;\n        var icon = void 0,\n          iconImg = void 0,\n          skipLabel = void 0;\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f, functionCache);\n          if (iconImage) {\n            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            var styleGeom = undefined;\n            if (spriteImage && spriteData && spriteData[icon]) {\n              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f, functionCache);\n              if (type == 2) {\n                var geom = feature.getGeometry();\n                // ol package and ol-debug.js only\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new _Feature.default('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache);\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      var stride = geom.getStride();\n                      var coordinates = geom.getFlatCoordinates();\n                      for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                        var x1 = coordinates[i_1];\n                        var y1 = coordinates[i_1 + 1];\n                        var x2 = coordinates[i_1 + stride];\n                        var y2 = coordinates[i_1 + stride + 1];\n                        var minX = Math.min(x1, x2);\n                        var minY = Math.min(y1, y2);\n                        var maxX = Math.max(x1, x2);\n                        var maxY = Math.max(y1, y2);\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n              if (type !== 2 || styleGeom) {\n                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f, functionCache);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f, functionCache) : null;\n                if (!iconColor || iconColor.a !== 0) {\n                  var icon_cache_key = icon + '.' + iconSize;\n                  if (iconColor !== null) {\n                    icon_cache_key += '.' + iconColor;\n                  }\n                  iconImg = iconImageCache[icon_cache_key];\n                  if (!iconImg) {\n                    var spriteImageData_1 = spriteData[icon];\n                    iconImg = new _Icon.default({\n                      color: iconColor ? [iconColor.r * 255, iconColor.g * 255, iconColor.b * 255, iconColor.a] : undefined,\n                      img: spriteImage,\n                      imgSize: spriteImgSize,\n                      size: [spriteImageData_1.width, spriteImageData_1.height],\n                      offset: [spriteImageData_1.x, spriteImageData_1.y],\n                      rotateWithView: iconRotationAlignment === 'map',\n                      scale: iconSize / spriteImageData_1.pixelRatio,\n                      displacement: 'icon-offset' in layout ? getValue(layer, 'layout', 'icon-offset', zoom, f, functionCache).map(function (v) {\n                        return -v * spriteImageData_1.pixelRatio;\n                      }) : undefined\n                    });\n                    iconImageCache[icon_cache_key] = iconImg;\n                  }\n                }\n                if (iconImg) {\n                  ++stylesLength;\n                  style = styles[stylesLength];\n                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                    style = new _Style.default();\n                    styles[stylesLength] = style;\n                  }\n                  style.setGeometry(styleGeom);\n                  iconImg.setRotation(placementAngle + (0, _util.deg2rad)(getValue(layer, 'layout', 'icon-rotate', zoom, f, functionCache)));\n                  iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f, functionCache));\n                  iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f, functionCache)]);\n                  style.setImage(iconImg);\n                  text = style.getText();\n                  style.setText(undefined);\n                  style.setZIndex(index);\n                  hasImage = true;\n                  skipLabel = false;\n                }\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n        if (type == 1 && layer.type === 'circle') {\n          ++stylesLength;\n          style = styles[stylesLength];\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = new _Style.default();\n            styles[stylesLength] = style;\n          }\n          var circleRadius = 'circle-radius' in paint ? getValue(layer, 'paint', 'circle-radius', zoom, f, functionCache) : 5;\n          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f, functionCache), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f, functionCache));\n          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f, functionCache), getValue(layer, 'paint', 'circle-opacity', zoom, f, functionCache));\n          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f, functionCache);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n          if (!iconImg) {\n            iconImg = new _Circle.default({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new _Stroke.default({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new _Fill.default({\n                color: circleColor\n              }) : undefined\n            });\n            iconImageCache[cache_key] = iconImg;\n          }\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n        var label = void 0;\n        if ('text-field' in layout) {\n          var textField = getValue(layer, 'layout', 'text-field', zoom, f, functionCache).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f, functionCache);\n        }\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = new _Style.default();\n              styles[stylesLength] = style;\n            }\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n          if (!style.getText()) {\n            style.setText(text || new _Text.default({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n          text = style.getText();\n          var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f, functionCache));\n          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f, functionCache);\n          var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f, functionCache);\n          var font = (0, _mapboxToCssFont.default)(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          var textTransform = layout['text-transform'];\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n          var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f, functionCache);\n          var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f, functionCache);\n          var wrappedLabel = type == 2 ? (0, _util.applyLetterSpacing)(label, letterSpacing) : (0, _util.wrapText)(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation((0, _util.deg2rad)(getValue(layer, 'layout', 'text-rotate', zoom, f, functionCache)));\n          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f, functionCache);\n          var placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache);\n          text.setPlacement(placement);\n          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f, functionCache);\n          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f, functionCache);\n          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f, functionCache);\n          // Text offset has to take halo width and line height into account\n          var vOffset = 0;\n          var hOffset = 0;\n          if (placement == 'point') {\n            var textAlign = 'center';\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n            text.setTextAlign(textAlign);\n            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f, functionCache);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle((0, _util.deg2rad)(getValue(layer, 'layout', 'text-max-angle', zoom, f, functionCache)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n          var textBaseline = 'middle';\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f, functionCache), opacity));\n          text.setFill(textColor);\n          var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f, functionCache), opacity);\n          if (haloColor) {\n            textHalo.setColor(haloColor);\n            // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n            textHaloWidth *= 2;\n            // 1/4 of text size (spec) x 2\n            var halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f, functionCache);\n          var padding = text.getPadding();\n          if (textPadding !== padding[0]) {\n            padding[0] = textPadding;\n            padding[1] = textPadding;\n            padding[2] = textPadding;\n            padding[3] = textPadding;\n          }\n          style.setZIndex(index);\n        }\n      }\n    };\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      _loop_1(i, ii);\n    }\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      if (recordLayer) {\n        if (typeof feature.set === 'function') {\n          // ol/Feature\n          feature.set('mapbox-layer', featureBelongsToLayer);\n        } else {\n          // ol/render/Feature\n          feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n        }\n      }\n      return styles;\n    }\n  };\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}"},"sourceMaps":null,"error":null,"hash":"52b7236afd6e29d041dddc7f010ed8a3","cacheData":{"env":{}}}